package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint skip 0
::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require pda
package require string::token

source ~/code/tcldocs/test/snippets.tcl

dict set δ (q0,ε,S) {qe {}}
dict set δ (q0,0,S) {q0 Z}
dict set δ (q0,0,Z) {q0 {Z Z}}
dict set δ (q0,1,Z) {q1 {}}
dict set δ (q1,1,Z) {q1 {}}
dict set δ (q1,ε,S) {qf {}}

test pda-1.0 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.1 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {0 0 0 0 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.2 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {0 0 0 0 1 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 0


test pda-1.3 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
    oo::objdefine M mixin -append Dump
} -body {
    M read {0 1 1}
    M dump
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{(q0,0,S) -> q0 {Z S}} {(q0,1,Z) -> q1 S} {illegal transition (q1,1,S)}}


test pda-1.4 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
    oo::objdefine M mixin -append Log
} -body {
    M read {0 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 0 -output {error     illegal transition (q1,1,S)
}


test pda-1.5 {} -setup {
    set res {}
} -body {
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q666 Z S F {qe qf}]
} -cleanup {
    log::lvSuppressLE i 1
} -result {illegal start state "q666"} -returnCodes error


test pda-1.6 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ {} s q0 Z S F {qe qf}]
    M addTransition q0      ε S {qe {}    {emit success "no input"}}
    M addTransition q0      0 S {q0 Z     {emit LVL [incr n]}}
    M addTransition q0      0 Z {q0 {Z Z} {emit LVL [incr n]}}
    M addTransition {q[01]} 1 Z {q1 {}    {emit LVL [incr n -1]}}
    M addTransition q1      ε S {qf {}    {emit success match}}
} -body {
    set slave [PDASlave new pdaslave.tcl {}]
    M read {} $slave
    lappend res [$slave eval emit]
    M read {0 1 1} $slave
    lappend res [$slave eval emit]
    M read {0 0 1 1} $slave
    lappend res [$slave eval emit]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{success {no input}} {LVL 1 LVL 0} {LVL 1 LVL 2 LVL 1 LVL 0 success match}}


test pda-2.0 {} -setup {
    set res {}
    PDA create M {
        Q {q0 q1 q2 q3 q4 qe qf}
        Σ {sp w nl}
        Γ {S}
        s q0
        Z S
        F {qe qf}
    }
    M addTransition {q[0-4]} nl S {q0 {}    {}}
    M addTransition q0       ε  S {qe {}    {emit success "no input"}}
    M addTransition q0       sp S {q0 {}    {}}
    M addTransition {q[01]}  w  S {q1 {}    {emit cmd $2}}
    M addTransition {q[12]}  sp S {q2 {}    {}}
    M addTransition {q[234]} w  S {q3 {}    {emit arg $2}}
    M addTransition {q[34]}  sp S {q4 {}    {}}
    M addTransition {q[1-4]} ε  S {qf {}    {emit success match}}
} -body {
    M read {} $slave
    lappend res [$slave eval emit]
    M read {sp sp {w foo} sp} $slave
    lappend res [$slave eval emit]
    M read {sp {w foo} sp sp {w bar} sp} $slave
    lappend res [$slave eval emit]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{success {no input}} {cmd foo success match} {cmd foo arg bar success match}}


test pda-2.1 {} -setup {
    set res {}
    PDA create M {
        Q {q0 q1 q2 q3 q4 qe qf}
        Σ {sp w n}
        Γ {S}
        s q0
        Z S
        F {qe qf}
    }
    oo::objdefine M mixin -append Dump
} -body {
    M addTransition {q[0-4]} nl S {q0 {}    {}}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {Error: addTransition: no matching keys for "nl"} -returnCodes error


test pda-2.2 {} -constraints {} -setup {
    set res {}
    PDA create M {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {sp w nl lb rb dq lc rc em}
        Γ {S B Q C}
        s q0
        Z S
        F {qe qf}
    }
    # qe    script empty
    # qf    script finished
    # q0    start state, before script
    #
    # q1    before command
    # q2    in word, more text may follow
    # q3    in word, no more text
    # q4    interword space or after command
    # 20180515 expands from 25 calls to 103 rules
    M addTransition q0       ε  S {qe {}    {emit success "no input"}}
    M addTransition {q[1-4]} ε  S {qf {}    {emit success done}}

    M addTransition q0       w  S {q2 -     {emit add $2}}
    M addTransition {q[12]}  w  * {q2 -     {emit add $2}}
    M addTransition q4       w  * {q2 -     {emit space add $2}}

    M addTransition q4       em * {q3 -     {emit space add $2}}

    M addTransition q0       nl S {q1 {}}
    M addTransition {q[1-4]} nl * {q1 -     {emit command}}

    M addTransition q1       sp * {q1 -}
    M addTransition {q[01]}  sp S {q1 {}}
    M addTransition {q[2-4]} sp * {q4 -}

    M addTransition {q[0-2]} lb S {q1 {B}   {emit enter B}}
    M addTransition {q[0-2]} dq S {q1 {Q}   {emit enter Q}}
    M addTransition {q[0-2]} lc S {q1 {C}   {emit enter C}}
    
    M addTransition {q[4]}   lb S {q1 {B}   {emit space enter B}}
    M addTransition {q[4]}   dq S {q1 {Q}   {emit space enter Q}}
    M addTransition {q[4]}   lc S {q1 {C}   {emit space enter C}}
    
    M addTransition {q[12]}  lb B {q1 {B B} {emit enter B}}
    M addTransition {q[12]}  dq B {q1 {Q B} {emit enter Q}}
    M addTransition {q[12]}  lc B {q1 {C B} {emit enter C}}

    M addTransition {q[4]}   lb B {q1 {B B} {emit space enter B}}
    M addTransition {q[4]}   dq B {q1 {Q B} {emit space enter Q}}
    M addTransition {q[4]}   lc B {q1 {C B} {emit space enter C}}

    M addTransition {q[12]}  lb Q {q1 {B Q} {emit enter B}}
    M addTransition {q[12]}  lc Q {q1 {C Q} {emit enter C}}
    
    M addTransition {q[4]}   lb Q {q1 {B Q} {emit space enter B}}
    M addTransition {q[4]}   lc Q {q1 {C Q} {emit space enter C}}
    
    M addTransition {q[12]}  lb C {q1 {B C} {emit enter B}}
    M addTransition {q[12]}  dq C {q1 {Q C} {emit enter Q}}
    M addTransition {q[12]}  lc C {q1 {C C} {emit enter C}}

    M addTransition {q[4]}   lb C {q1 {B C} {emit space enter B}}
    M addTransition {q[4]}   dq C {q1 {Q C} {emit space enter Q}}
    M addTransition {q[4]}   lc C {q1 {C C} {emit space enter C}}

    M addTransition {q[1-4]} rb B {q2 {}    {emit leave}}
    
    M addTransition {q[124]} dq Q {q3 {}    {emit leave}}

    M addTransition {q[1-4]} rc C {q3 {}    {emit leave}}
    
} -body {
    set lex {
    {(\\.|[\w:$!%&'()*,-./?@+<=>^`|~])+}    w
    {[ \t]+}                                sp
    {\n}                                    nl
    {\;}                                    sc
    {\#}                                    ns
    {\"\"|\{\}|\[\]}                        em
    {\"}                                    dq
    {\{\*\}}                                ex
    {\{}                                    lc
    {\}}                                    rc
    {\[}                                    lb
    {\]}                                    rb
    .                                       Other
    }
    set slave [PDASlave new pdaslave.tcl {
        emit init
        emit enter S
    }]
    set code [lindex $snippets 0]
    set tokens [::string::token text $lex $code]
    M read [lmap token $tokens {lassign $token sym beg end ; list $sym [string range $code $beg $end]}] $slave
    lappend res [$slave eval emit]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{init enter S add set space add fp space enter B add open space enter Q add {D:\\RWTH\\Mini} space add {thesis\\EclipseTCL\\TCL} space add {trial\\excelv1.csv} leave space add r leave command add set space add secondColumnData space add {{}} command add while space enter C enter B add gets space add {$fp} space add line leave add >=0 leave space enter C command add if space enter C enter B add llength space add {$line} leave add >0 leave space enter C command add lappend space add secondColumnData space enter B add lindex space enter B add split space add {$line} space enter Q add , leave leave space add 1 leave command leave command leave command add close space add {$fp} command add puts space add {$secondColumnData} success done}}



    package require sqlite3
    catch {::dbcmd close}
    sqlite3 ::dbcmd :memory:
    source ../../tcldocs/topdir/lib/td/dbinit.tcl
    source ../../tcldocs/topdir/lib/td/db.tcl
    set slave [PDASlave new pdaslave.tcl {
        action init
    }]
    $slave expose source
    $slave alias tokenize string::token text
    if no {
    $slave alias dbcmd dbcmd
    $slave alias dbGetRowIds dbGetRowIds
    $slave alias dbGetRowIDs2 dbGetRowIDs2
    $slave alias dbGet dbGet
    $slave alias dbMakeExpLex dbMakeExpLex
    }
    $slave eval {
        namespace eval log {}
        proc log::logMsg args {}
        source parse-tcldocs.tcl
    }
        proc parseExpressions strs {
            log::log d [info level 0] 
            global explex
            if {![info exists explex]} {
                set explex [dbMakeExpLex]
            }
            set result {}
            foreach str $strs {
                foreach tok [::string::token text $explex $str] {
                    set label [lindex $tok 0]
                    if {$label ni {w _}} {
                        foreach type {operator function} {
                            lappend result {*}[dbGetRowIds $type $label]
                        }
                    }
                }
            }
            return $result
        }
        proc getResult output {
            # TODO move outside slave so that items can be added or removed
            set data {}
            dict for {k v} $output {
                set v [lsort -unique -dictionary $v]
                set ids [if {$k eq "expressions"} {
                    parseExpressions $v
                } else {
                    dbGetRowIds $k {*}$v
                }]
                foreach id $ids {
                    dict incr data $id
                }
            }
            return [join [lmap rowid [lsort -integer [dict keys $data]] {dbGet $rowid}] \n]
        }
    set machineDefinition {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {w sp nl sc ns em dq ex lc rc lb rb}
        Γ {S B Q C O}
        s q0
        Z S
        F {qe qf}
    }
    set lex {
    {(\\.|[\w:$!%&'()*,-./?@+<=>^`|~])+}    w
    {[ \t]+}                                sp
    {\n}                                    nl
    {\;}                                    sc
    {\#}                                    ns
    {\"\"|\{\}|\[\]}                        em
    {\"}                                    dq
    {\{\*\}}                                ex
    {\{}                                    lc
    {\}}                                    rc
    {\[}                                    lb
    {\]}                                    rb
    .                                       Other
    }

test pda-3.0 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    # qe    script empty
    # qf    script finished
    # q0    start state, before script
    #
    # q1    before command
    # q2    in word, more text may follow
    # q3    in word, no more text
    # q4    interword space or after command
    M addTransition q0       ε  S        {qe {}    {action succ "no input"}}
    M addTransition {q[1-4]} ε  S        {qf {}    {action succ done}}

    M addTransition q0       w  S        {q2 -     {action add $2}}
    M addTransition {q[12]}  w  *        {q2 -     {action add $2}}
    M addTransition q4       w  *        {q2 -     {action space ; action add $2}}

    M addTransition q4       em *        {q3 -     {action space ; action add $2}}

    M addTransition q0       nl S        {q1 {}}
    M addTransition q1       *  O        {q1 -}
    M addTransition q1       nl O        {q1 {}}
    M addTransition {q[1-4]} nl {[SBQC]} {q1 -     {action command}}

    M addTransition q1       sp *        {q1 -}
    M addTransition {q[01]}  sp S        {q1 {}}
    M addTransition {q[2-4]} sp *        {q4 -}

    M addTransition q1       ns S        {q1 {O}}
    M addTransition q1       ns B        {q1 {O B}}
    M addTransition q1       ns Q        {q1 {O Q}}
    M addTransition q1       ns C        {q1 {O C}}

    M addTransition {q[014]} ex *        {q2 -     {action space ; action topic $2}}

    M addTransition {q[01]}  lb S        {q1 {B}   {action enter B}}
    M addTransition {q[01]}  dq S        {q1 {Q}   {action enter Q}}
    M addTransition {q[01]}  lc S        {q1 {C}   {action enter C}}
    
    M addTransition q2       lb S        {q1 {B}   {action enter B}}
    M addTransition q2       lb B        {q1 {B B} {action enter B}}
    M addTransition q2       lb Q        {q1 {B Q} {action enter B}}
    M addTransition q2       lb C        {q1 {B C} {action enter B}}
    M addTransition q2       dq *        {q2 -     {action add $2}}
    M addTransition q2       lc *        {q2 -     {action add $2}}
    
    M addTransition q4       lb S        {q1 {B}   {action space ; action enter B}}
    M addTransition q4       dq S        {q1 {Q}   {action space ; action enter Q}}
    M addTransition q4       lc S        {q1 {C}   {action space ; action enter C}}
    
    M addTransition q1       lb B        {q1 {B B} {action enter B}}
    M addTransition q1       dq B        {q1 {Q B} {action enter Q}}
    M addTransition q1       lc B        {q1 {C B} {action enter C}}

    M addTransition q4       lb B        {q1 {B B} {action space ; action enter B}}
    M addTransition q4       dq B        {q1 {Q B} {action space ; action enter Q}}
    M addTransition q4       lc B        {q1 {C B} {action space ; action enter C}}

    M addTransition q1       lb Q        {q1 {B Q} {action enter B}}
    M addTransition q1       lc Q        {q1 {C Q} {action enter C}}
    
    M addTransition q4       lb Q        {q1 {B Q} {action space ; action enter B}}
    M addTransition q4       lc Q        {q1 {C Q} {action space ; action enter C}}
    
    M addTransition q1       lb C        {q1 {B C} {action enter B}}
    M addTransition q1       dq C        {q1 {Q C} {action enter Q}}
    M addTransition q1       lc C        {q1 {C C} {action enter C}}

    M addTransition q4       lb C        {q1 {B C} {action space ; action enter B}}
    M addTransition q4       dq C        {q1 {Q C} {action space ; action enter Q}}
    M addTransition q4       lc C        {q1 {C C} {action space ; action enter C}}

    M addTransition q2       rb {[SQC]}  {q2 -     {action add $2}}
    M addTransition {q[1-4]} rb B        {q2 {}    {action leave}}
    M addTransition q2       dq {[SBC]}  {q2 -     {action add $2}}
    M addTransition {q[1-4]} dq Q        {q3 {}    {action leave}}
    M addTransition q2       rc {[SBQ]}  {q2 -     {action add $2}}
    M addTransition {q[1-4]} rc C        {q3 {}    {action leave}}
    
    set transitions [M get δ]
} -body {
    set code [lindex $snippets 0]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[> (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Greater than")
[>= (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Greater than or equal")
[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[gets](http://www.tcl.tk/man/tcl/TclCmd/gets.htm "Read a line from a channel")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[lappend](http://www.tcl.tk/man/tcl/TclCmd/lappend.htm "Append list elements onto a variable")
[lindex](http://www.tcl.tk/man/tcl/TclCmd/lindex.htm "Retrieve an element from a list")
[llength](http://www.tcl.tk/man/tcl/TclCmd/llength.htm "Count the number of elements in a list")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[split](http://www.tcl.tk/man/tcl/TclCmd/split.htm "Split a string into a proper Tcl list")
[while](http://www.tcl.tk/man/tcl/TclCmd/while.htm "Execute script repeatedly as long as a condition is met")}


test pda-3.1 {} -constraints {} -setup {
    set res {}
    PDA create M {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {sp w nl lb rb dq lc rc em}
        Γ {S B Q C}
        s q0
        Z S
        F {qe qf}
    }
    M set δ $transitions
} -body {
    set code [lindex $snippets 1]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[lappend](http://www.tcl.tk/man/tcl/TclCmd/lappend.htm "Append list elements onto a variable")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[read](http://www.tcl.tk/man/tcl/TclCmd/read.htm "Read from a channel")
[regexp](http://www.tcl.tk/man/tcl/TclCmd/regexp.htm "Match a regular expression against a string")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")}


test pda-3.2 {} -constraints {} -setup {
    set res {}
    PDA create M {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {sp w nl lb rb dq lc rc em}
        Γ {S B Q C}
        s q0
        Z S
        F {qe qf}
    }
    M set δ $transitions
} -body {
    set code [lindex $snippets 2]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[lmap (Tcl 8.5)](http://wiki.tcl.tk/40570 "Getting lmap for Tcl 8.5 and earlier")
[lmap](http://www.tcl.tk/man/tcl/TclCmd/lmap.htm "Iterate over all elements in one or more lists and collect results")
[scan](http://www.tcl.tk/man/tcl/TclCmd/scan.htm "Parse string using conversion specifiers in the style of sscanf")
[split](http://www.tcl.tk/man/tcl/TclCmd/split.htm "Split a string into a proper Tcl list")
[string](http://www.tcl.tk/man/tcl/TclCmd/string.htm "Manipulate strings")}


test pda-3.3 {} -constraints {} -setup {
    set res {}
    PDA create M {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {sp w nl lb rb dq lc rc em}
        Γ {S B Q C}
        s q0
        Z S
        F {qe qf}
    }
    M set δ $transitions
} -body {
    set code [lindex $snippets 3]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[csv (package)](http://core.tcl.tk/tcllib/doc/trunk/embedded/www/tcllib/files/modules/csv/csv.html "Procedures to handle CSV data.")
[lassign](http://www.tcl.tk/man/tcl/TclCmd/lassign.htm "Assign list elements to variables")
[lmap (Tcl 8.5)](http://wiki.tcl.tk/40570 "Getting lmap for Tcl 8.5 and earlier")
[lmap](http://www.tcl.tk/man/tcl/TclCmd/lmap.htm "Iterate over all elements in one or more lists and collect results")
[package](http://www.tcl.tk/man/tcl/TclCmd/package.htm "Facilities for package loading and version control")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[split](http://www.tcl.tk/man/tcl/TclCmd/split.htm "Split a string into a proper Tcl list")
[string](http://www.tcl.tk/man/tcl/TclCmd/string.htm "Manipulate strings")}


test pda-3.4 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 4]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[< (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Less than")
[for](http://www.tcl.tk/man/tcl/TclCmd/for.htm "'For' loop")
[incr](http://www.tcl.tk/man/tcl/TclCmd/incr.htm "Increment the value of a variable")
[llength](http://www.tcl.tk/man/tcl/TclCmd/llength.htm "Count the number of elements in a list")
[lsearch](http://www.tcl.tk/man/tcl/TclCmd/lsearch.htm "See if a list contains a particular element")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")}


test pda-3.5 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 5]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[incr](http://www.tcl.tk/man/tcl/TclCmd/incr.htm "Increment the value of a variable")}


test pda-3.6 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 6]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[> (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Greater than")
[array](http://www.tcl.tk/man/tcl/TclCmd/array.htm "Manipulate array variables")
[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")}


test pda-3.7 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 7]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[lmap (Tcl 8.5)](http://wiki.tcl.tk/40570 "Getting lmap for Tcl 8.5 and earlier")
[lmap](http://www.tcl.tk/man/tcl/TclCmd/lmap.htm "Iterate over all elements in one or more lists and collect results")
[proc](http://www.tcl.tk/man/tcl/TclCmd/proc.htm "Create a Tcl procedure")
[return](http://www.tcl.tk/man/tcl/TclCmd/return.htm "Return from a procedure, or set return code of a script")
[scan](http://www.tcl.tk/man/tcl/TclCmd/scan.htm "Parse string using conversion specifiers in the style of sscanf")
[split](http://www.tcl.tk/man/tcl/TclCmd/split.htm "Split a string into a proper Tcl list")
[string](http://www.tcl.tk/man/tcl/TclCmd/string.htm "Manipulate strings")}


test pda-3.8 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 8]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[! (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Logical negation")
[dict](http://www.tcl.tk/man/tcl/TclCmd/dict.htm "Manipulate dictionaries")
[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[incr](http://www.tcl.tk/man/tcl/TclCmd/incr.htm "Increment the value of a variable")
[lrepeat](http://www.tcl.tk/man/tcl/TclCmd/lrepeat.htm "Build a list by repeating elements")
[lset](http://www.tcl.tk/man/tcl/TclCmd/lset.htm "Change an element in a list")
[proc](http://www.tcl.tk/man/tcl/TclCmd/proc.htm "Create a Tcl procedure")
[return](http://www.tcl.tk/man/tcl/TclCmd/return.htm "Return from a procedure, or set return code of a script")
[scan](http://www.tcl.tk/man/tcl/TclCmd/scan.htm "Parse string using conversion specifiers in the style of sscanf")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[split](http://www.tcl.tk/man/tcl/TclCmd/split.htm "Split a string into a proper Tcl list")
[string](http://www.tcl.tk/man/tcl/TclCmd/string.htm "Manipulate strings")}


test pda-3.9 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 9]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[! (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Logical negation")
[- (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Numeric negation/Subtraction")
[== (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Equality")
[> (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Greater than")
[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[eof](http://www.tcl.tk/man/tcl/TclCmd/eof.htm "Check for end of file condition on channel")
[file](http://www.tcl.tk/man/tcl/TclCmd/file.htm "Manipulate file names and attributes")
[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[gets](http://www.tcl.tk/man/tcl/TclCmd/gets.htm "Read a line from a channel")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[list](http://www.tcl.tk/man/tcl/TclCmd/list.htm "Create a list")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[string](http://www.tcl.tk/man/tcl/TclCmd/string.htm "Manipulate strings")
[while](http://www.tcl.tk/man/tcl/TclCmd/while.htm "Execute script repeatedly as long as a condition is met")}


test pda-3.10 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 10]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[lappend](http://www.tcl.tk/man/tcl/TclCmd/lappend.htm "Append list elements onto a variable")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[read](http://www.tcl.tk/man/tcl/TclCmd/read.htm "Read from a channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[string](http://www.tcl.tk/man/tcl/TclCmd/string.htm "Manipulate strings")}


test pda-3.11 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 11]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[read](http://www.tcl.tk/man/tcl/TclCmd/read.htm "Read from a channel")
[regsub](http://www.tcl.tk/man/tcl/TclCmd/regsub.htm "Perform substitutions based on regular expression pattern matching")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")}


test pda-3.12 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 12]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[{*} (syntax)](http://www.tcl.tk/man/tcl/TclCmd/Tcl.htm "Expand arguments")
[eq (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "String equality")
[concat](http://www.tcl.tk/man/tcl/TclCmd/concat.htm "Join lists together")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[lassign](http://www.tcl.tk/man/tcl/TclCmd/lassign.htm "Assign list elements to variables")
[lmap (Tcl 8.5)](http://wiki.tcl.tk/40570 "Getting lmap for Tcl 8.5 and earlier")
[lmap](http://www.tcl.tk/man/tcl/TclCmd/lmap.htm "Iterate over all elements in one or more lists and collect results")
[proc](http://www.tcl.tk/man/tcl/TclCmd/proc.htm "Create a Tcl procedure")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")}


test pda-3.13 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 13]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    set result [lindex [$slave eval emit] 0]
    dict lappend result command continue
    getResult $result
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[ni (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "List non-membership")
[continue](http://www.tcl.tk/man/tcl/TclCmd/continue.htm "Skip to the next iteration of a loop")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[lmap (Tcl 8.5)](http://wiki.tcl.tk/40570 "Getting lmap for Tcl 8.5 and earlier")
[lmap](http://www.tcl.tk/man/tcl/TclCmd/lmap.htm "Iterate over all elements in one or more lists and collect results")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")}


test pda-3.14 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 14]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[global](http://www.tcl.tk/man/tcl/TclCmd/global.htm "Access global variables")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[proc](http://www.tcl.tk/man/tcl/TclCmd/proc.htm "Create a Tcl procedure")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[string](http://www.tcl.tk/man/tcl/TclCmd/string.htm "Manipulate strings")
[tk_getOpenFile](http://www.tcl.tk/man/tcl/TkCmd/getOpenFile.htm "Pop up a dialog box for the user to select a file to open or save.")}


test pda-3.15 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 15]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[! (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Logical negation")
[+ (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Addition")
[== (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Equality")
[eof](http://www.tcl.tk/man/tcl/TclCmd/eof.htm "Check for end of file condition on channel")
[expr](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Evaluate an expression")
[gets](http://www.tcl.tk/man/tcl/TclCmd/gets.htm "Read a line from a channel")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[lindex](http://www.tcl.tk/man/tcl/TclCmd/lindex.htm "Retrieve an element from a list")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[regexp](http://www.tcl.tk/man/tcl/TclCmd/regexp.htm "Match a regular expression against a string")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[while](http://www.tcl.tk/man/tcl/TclCmd/while.htm "Execute script repeatedly as long as a condition is met")}


test pda-3.16 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 16]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[% (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Remainder")
[dict](http://www.tcl.tk/man/tcl/TclCmd/dict.htm "Manipulate dictionaries")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[llength](http://www.tcl.tk/man/tcl/TclCmd/llength.htm "Count the number of elements in a list")
[proc](http://www.tcl.tk/man/tcl/TclCmd/proc.htm "Create a Tcl procedure")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[return](http://www.tcl.tk/man/tcl/TclCmd/return.htm "Return from a procedure, or set return code of a script")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")}


test pda-3.17 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 17]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[lindex](http://www.tcl.tk/man/tcl/TclCmd/lindex.htm "Retrieve an element from a list")
[list](http://www.tcl.tk/man/tcl/TclCmd/list.htm "Create a list")
[proc](http://www.tcl.tk/man/tcl/TclCmd/proc.htm "Create a Tcl procedure")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[string](http://www.tcl.tk/man/tcl/TclCmd/string.htm "Manipulate strings")}


test pda-3.18 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 18]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[eq (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "String equality")
[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[join](http://www.tcl.tk/man/tcl/TclCmd/join.htm "Create a string by joining together list elements")
[lappend](http://www.tcl.tk/man/tcl/TclCmd/lappend.htm "Append list elements onto a variable")
[lindex](http://www.tcl.tk/man/tcl/TclCmd/lindex.htm "Retrieve an element from a list")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[split](http://www.tcl.tk/man/tcl/TclCmd/split.htm "Split a string into a proper Tcl list")}


test pda-3.19 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 19]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[{*} (syntax)](http://www.tcl.tk/man/tcl/TclCmd/Tcl.htm "Expand arguments")
[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[info](http://www.tcl.tk/man/tcl/TclCmd/info.htm "Return information about the state of the Tcl interpreter")
[lappend](http://www.tcl.tk/man/tcl/TclCmd/lappend.htm "Append list elements onto a variable")
[namespace](http://www.tcl.tk/man/tcl/TclCmd/namespace.htm "Create and manipulate contexts for commands and variables")
[proc](http://www.tcl.tk/man/tcl/TclCmd/proc.htm "Create a Tcl procedure")
[return](http://www.tcl.tk/man/tcl/TclCmd/return.htm "Return from a procedure, or set return code of a script")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")}


test pda-3.20 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 20]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    set result [lindex [$slave eval emit] 0]
    dict lappend result command continue
    getResult $result
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[!= (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Inequality")
[% (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Remainder")
[&& (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "logical AND operator")
[+ (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Addition")
[- (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Numeric negation/Subtraction")
[<= (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Less than or equal")
[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[continue](http://www.tcl.tk/man/tcl/TclCmd/continue.htm "Skip to the next iteration of a loop")
[exec](http://www.tcl.tk/man/tcl/TclCmd/exec.htm "Invoke subprocesses")
[expr](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Evaluate an expression")
[gets](http://www.tcl.tk/man/tcl/TclCmd/gets.htm "Read a line from a channel")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[while](http://www.tcl.tk/man/tcl/TclCmd/while.htm "Execute script repeatedly as long as a condition is met")}


test pda-3.21 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 21]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[&& (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "logical AND operator")
[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[dict](http://www.tcl.tk/man/tcl/TclCmd/dict.htm "Manipulate dictionaries")
[foreach](http://www.tcl.tk/man/tcl/TclCmd/foreach.htm "Iterate over all elements in one or more lists")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[proc](http://www.tcl.tk/man/tcl/TclCmd/proc.htm "Create a Tcl procedure")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[read](http://www.tcl.tk/man/tcl/TclCmd/read.htm "Read from a channel")
[regexp](http://www.tcl.tk/man/tcl/TclCmd/regexp.htm "Match a regular expression against a string")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[split](http://www.tcl.tk/man/tcl/TclCmd/split.htm "Split a string into a proper Tcl list")}


test pda-3.22 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
    oo::objdefine M mixin -append Dump
} -body {
    set code [lindex $snippets 22]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[== (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Equality")
[>= (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Greater than or equal")
[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[gets](http://www.tcl.tk/man/tcl/TclCmd/gets.htm "Read a line from a channel")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[lindex](http://www.tcl.tk/man/tcl/TclCmd/lindex.htm "Retrieve an element from a list")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[while](http://www.tcl.tk/man/tcl/TclCmd/while.htm "Execute script repeatedly as long as a condition is met")}


test pda-3.23 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 23]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[== (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Equality")
[>= (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Greater than or equal")
[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[file](http://www.tcl.tk/man/tcl/TclCmd/file.htm "Manipulate file names and attributes")
[gets](http://www.tcl.tk/man/tcl/TclCmd/gets.htm "Read a line from a channel")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[lindex](http://www.tcl.tk/man/tcl/TclCmd/lindex.htm "Retrieve an element from a list")
[lset](http://www.tcl.tk/man/tcl/TclCmd/lset.htm "Change an element in a list")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[while](http://www.tcl.tk/man/tcl/TclCmd/while.htm "Execute script repeatedly as long as a condition is met")}


test pda-3.24 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 24]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")}


test pda-3.25 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code [lindex $snippets 25]
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[array](http://www.tcl.tk/man/tcl/TclCmd/array.htm "Manipulate array variables")
[catch](http://www.tcl.tk/man/tcl/TclCmd/catch.htm "Evaluate script and trap exceptional returns")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[parray](http://www.tcl.tk/man/tcl/TclCmd/library.htm "Prints on standard output the names and values of all the elements in a named array")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[argv (variable)](http://www.tcl.tk/man/tcl/TclCmd/tclvars.htm "Tcl list of arguments to tclsh or wish")}


test pda-4.0 {} -constraints {} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code {puts $::argv}
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup  {
    M destroy
    log::lvSuppressLE i 1
} -result {[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[argv (variable)](http://www.tcl.tk/man/tcl/TclCmd/tclvars.htm "Tcl list of arguments to tclsh or wish")}


test static-4.1 {} -constraints {TODO} -setup {
    set res {}
    PDA create M $machineDefinition
    M set δ $transitions
} -body {
    set code {oo::class new foo ; foo new bar}
    set tokens [lmap token [::string::token text $lex $code] {
        lassign $token sym beg end
        list $sym [string range $code $beg $end]
    }]
    M read $tokens $slave
    getResult [lindex [$slave eval emit] 0]
} -cleanup  {
    M destroy
    log::lvSuppressLE i 1
} -result {[oo::class](http://www.tcl.tk/man/tcl/TclCmd/class.htm "Class of all classes")
[new (method of `class`)](http://www.tcl.tk/man/tcl/TclCmd/class.htm "Create unnamed instance")}


# TODO test from markdown


test textstr-1.0 {} -constraints {} -setup {
    set res {}
} -body {
    #results check [::$ch parser::parse {idx_expr ; brace_expr}]
    set result [dict create topic {idx_expr brace_expr}]
    getResult $result
} -cleanup  {
    log::lvSuppressLE i 1
} -result {

*Syntax of Tcl index expressions:*

  * *integer* zero-based index number
  * `end` the last element
  * `end`*-N* the *n*th element before the last element
  * `end`*+N* the *n*th element after the last element (in practice, *N* should be negative)
  * *M-N* the *n*th element before element *m*
  * *M+N* the *n*th element after element *m*

There can be no whitespace within the expression.


*Brace your expressions*

The [expr](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Evaluate an expression") command (and by extension, the commands `for`, `if`, and `while`, which use the same mechanism to evaluate their conditions) interprets an expression string that is constructed from its arguments. Note that the language of the expression string isn't Tcl, but specific to the `expr` command's expression evaluator: the languages share many syntactic forms, but are fundamentally different with infix, operator-based structure for the `expr` language and prefix, command-based structure for Tcl.

Letting the Tcl interpreter evaluate the arguments before passing them to `expr` can lead to

1. *double substitution*, which has security problems similar to SQL injection attacks.
1. iterative commands (`for`, `while`) getting constant-valued condition arguments, leading to infinite loops.
1. all substitutions (and thus their side-effects) always occurring while `expr` can selectively suppress some of them.

Therefore, it is almost always better to provide the expression string as a braced (escaped) string, which will *not* be evaluated by the Tcl interpreter, only the `expr` interpreter.

Note that while unbraced arguments to `expr` are allowed to be a invalid expression string as long as the argument evaluation transforms them into a valid one, braced expressions must be valid as they are (e.g. variable or command substitutions must be simple operands and not operators or complex expressions).

Another benefit from using braced expression strings is that the byte compiler usually can generate more efficient code (5 - 10x faster) from them.}


::tcltest::cleanupTests

package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint skip 0
::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require pda
package require string::token

source ~/code/tcldocs/test/snippets.tcl

dict set δ q0 ε S {qe {}}
dict set δ q0 0 S {q0 Z}
dict set δ q0 0 Z {q0 {Z Z}}
dict set δ q0 1 Z {q1 {}}
dict set δ q1 1 Z {q1 {}}
dict set δ q1 ε S {qf {}}

test pda-1.0 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.1 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {0 0 0 0 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.2 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {0 0 0 0 1 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 0


test pda-1.3 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
    oo::objdefine M mixin -append Dump
} -body {
    M read {0 1 1}
    M dump
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{(q0,0,S) -> q0 {Z S}} {(q0,1,Z) -> q1 S} {{illegal transition (q1,1,S)}}}


test pda-1.4 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ {} s q0 Z S F {qe qf}]
    oo::objdefine M mixin -append Slave
    M addTransition q0      ε S {qe {}    {emit success "no input"}}
    M addTransition q0      0 S {q0 Z     {emit LVL [incr n]}}
    M addTransition q0      0 Z {q0 {Z Z} {emit LVL [incr n]}}
    M addTransition {q[01]} 1 Z {q1 {}    {emit LVL [incr n -1]}}
    M addTransition q1      ε S {qf {}    {emit success match}}
} -body {
    M read {}
    lappend res [M output]
    M read {0 1 1}
    lappend res [M output]
    M read {0 0 1 1}
    lappend res [M output]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{success {no input}} {LVL 1 LVL 0} {LVL 1 LVL 2 LVL 1 LVL 0 success match}}


test pda-2.0 {} -setup {
    set res {}
    PDA create M {
        Q {q0 q1 q2 q3 q4 qe qf}
        Σ {sp w nl}
        Γ {S}
        s q0
        Z S
        F {qe qf}
    }
    oo::objdefine M mixin -append Slave
    M addTransition {q[0-4]} nl S {q0 {}    {}}
    M addTransition q0       ε  S {qe {}    {emit success "no input"}}
    M addTransition q0       sp S {q0 {}    {}}
    M addTransition {q[01]}  w  S {q1 {}    {emit cmd $2}}
    M addTransition {q[12]}  sp S {q2 {}    {}}
    M addTransition {q[234]} w  S {q3 {}    {emit arg $2}}
    M addTransition {q[34]}  sp S {q4 {}    {}}
    M addTransition {q[1-4]} ε  S {qf {}    {emit success match}}
} -body {
    M read {}
    lappend res [M output]
    M read {sp sp {w foo} sp}
    lappend res [M output]
    M read {sp {w foo} sp sp {w bar} sp}
    lappend res [M output]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{success {no input}} {cmd foo success match} {cmd foo arg bar success match}}


test pda-2.1 {} -setup {
    set res {}
    PDA create M {
        Q {q0 q1 q2 q3 q4 qe qf}
        Σ {sp w n}
        Γ {S}
        s q0
        Z S
        F {qe qf}
    }
    oo::objdefine M mixin -append Dump Slave
} -body {
    M addTransition {q[0-4]} nl S {q0 {}    {}}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {Error: addTransition: no matching keys for "nl"} -returnCodes error


test pda-2.2 {} -setup {
    set res {}
    PDA create M {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {sp w nl lb rb dq lc rc em}
        Γ {S B Q C}
        s q0
        Z S
        F {qe qf}
    }
    set script {
        emit init
        emit enter S
    }
    oo::objdefine M mixin -append Slave
    # qe    script empty
    # qf    script finished
    # q0    start state, before script
    #
    # q1    before command
    # q2    in word, more text may follow
    # q3    in word, no more text
    # q4    interword space or after command
    # 20180515 expands from 25 calls to 103 rules
    M addTransition q0        ε  S {qe {}    {emit success "no input"}}
    M addTransition {q[1-4]}  ε  S {qf {}    {emit success done}}

    M addTransition q0        w  S {q2 -     {emit add $2}}
    M addTransition {q[12]}   w  * {q2 -     {emit add $2}}
    M addTransition q4        w  * {q2 -     {emit space add $2}}

    M addTransition q4        em * {q3 -     {emit space add $2}}

    M addTransition q0        nl S {q1 {}}
    M addTransition {q[1-4]}  nl * {q1 -     {emit command}}

    M addTransition q1        sp * {q1 -}
    M addTransition {q[01]}   sp S {q1 {}}
    M addTransition {q[2-4]}  sp * {q4 -}

    M addTransition {q[0-2]} lb S {q1 {B}   {emit enter B}}
    M addTransition {q[0-2]} dq S {q1 {Q}   {emit enter Q}}
    M addTransition {q[0-2]} lc S {q1 {C}   {emit enter C}}
    
    M addTransition {q[4]}   lb S {q1 {B}   {emit space enter B}}
    M addTransition {q[4]}   dq S {q1 {Q}   {emit space enter Q}}
    M addTransition {q[4]}   lc S {q1 {C}   {emit space enter C}}
    
    M addTransition {q[12]}  lb B {q1 {B B} {emit enter B}}
    M addTransition {q[12]}  dq B {q1 {Q B} {emit enter Q}}
    M addTransition {q[12]}  lc B {q1 {C B} {emit enter C}}

    M addTransition {q[4]}   lb B {q1 {B B} {emit space enter B}}
    M addTransition {q[4]}   dq B {q1 {Q B} {emit space enter Q}}
    M addTransition {q[4]}   lc B {q1 {C B} {emit space enter C}}

    M addTransition {q[12]}  lb Q {q1 {B Q} {emit enter B}}
    M addTransition {q[12]}  lc Q {q1 {C Q} {emit enter C}}
    
    M addTransition {q[4]}   lb Q {q1 {B Q} {emit space enter B}}
    M addTransition {q[4]}   lc Q {q1 {C Q} {emit space enter C}}
    
    M addTransition {q[12]}  lb C {q1 {B C} {emit enter B}}
    M addTransition {q[12]}  dq C {q1 {Q C} {emit enter Q}}
    M addTransition {q[12]}  lc C {q1 {C C} {emit enter C}}

    M addTransition {q[4]}   lb C {q1 {B C} {emit space enter B}}
    M addTransition {q[4]}   dq C {q1 {Q C} {emit space enter Q}}
    M addTransition {q[4]}   lc C {q1 {C C} {emit space enter C}}

    M addTransition {q[1-4]} rb B {q2 {}    {emit leave}}
    
    M addTransition {q[124]} dq Q {q3 {}    {emit leave}}

    M addTransition {q[1-4]} rc C {q3 {}    {emit leave}}
    
} -body {
    set lex {
    {(\\.|[\w:$!%&'()*,-./?@+<=>^`|~])+}    w
    {[ \t]+}                                sp
    {\n}                                    nl
    {\;}                                    sc
    {\#}                                    ns
    {\"\"|\{\}|\[\]}                        em
    {\"}                                    dq
    {\{\*\}}                                ex
    {\{}                                    lc
    {\}}                                    rc
    {\[}                                    lb
    {\]}                                    rb
    .                                       Other
    }
    set code [lindex $snippets 0]
    set tokens [::string::token text $lex $code]
    M read [lmap token $tokens {lassign $token sym beg end ; list $sym [string range $code $beg $end]}] $script
    lappend res [M output]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {}


::tcltest::cleanupTests

package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint skip 0
::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require pda
package require string::token

dict set δ q2 {} S {q1 {}}
dict set δ q2 0  S {q2 0}
dict set δ q2 0  0 {q2 {0 0}}
dict set δ q2 1  0 {q3 {}}
dict set δ q3 1  0 {q3 {}}
dict set δ q3 {} S {q4 {}}

test pda-1.0 {} -setup {
    set res {}
    PDA create M {q1 q2 q3 q4} {0 1} {S 0} ${δ} q2 S {q1 q4}
} -body {
    M run {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.1 {} -setup {
    set res {}
    PDA create M {q1 q2 q3 q4} {0 1} {S 0} ${δ} q2 S {q1 q4}
} -body {
    M run {0 0 0 0 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.2 {} -setup {
    set res {}
    PDA create M {q1 q2 q3 q4} {0 1} {S 0} ${δ} q2 S {q1 q4}
} -body {
    M run {0 0 0 0 1 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 0


test pda-1.3 {} -setup {
    set res {}
    PDA create M {q1 q2 q3 q4} {0 1} {S 0} ${δ} q2 S {q1 q4}
} -body {
    M run {0 1 1}
    M dump
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{q2 0 S -> q2 0 {} {0 S}} {q2 1 0 -> q3 {} {} S} {Error: Illegal transition (q3,1,S)} 0}


test pda-1.4 {} -setup {
    set res {}
    dict set δ1 q2 {} S {q1 {}    {emit success "no input"}}
    dict set δ1 q2 0  S {q2 0     {emit LVL [incr n]}}
    dict set δ1 q2 0  0 {q2 {0 0} {emit LVL [incr n]}}
    dict set δ1 q2 1  0 {q3 {}    {emit LVL [incr n -1]}}
    dict set δ1 q3 1  0 {q3 {}    {emit LVL [incr n -1]}}
    dict set δ1 q3 {} S {q4 {}    {emit success match}}
    PDA create M {q1 q2 q3 q4} {0 1} {S 0} ${δ1} q2 S {q1 q4}
} -body {
    M run {}
    lappend res [M output]
    M reset
    M run {0 1 1}
    lappend res [M output]
    M reset
    M run {0 0 1 1}
    lappend res [M output]
} -cleanup {
    M destroy
    unset δ1
    log::lvSuppressLE i 1
} -result {{success {no input}} {LVL 1 LVL 0} {LVL 1 LVL 2 LVL 1 LVL 0 success match}}


test pda-2.0 {} -setup {
    set res {}
    dict set δ1 q1 {} S {q0 {}    {emit success "no input"}}
    dict set δ1 q1 sp S {q1 {}    {}}
    dict set δ1 q1 nl S {q1 {}    {}}
    dict set δ1 q1 w  S {q2 {}    {emit cmd [lindex $token 1]}}
    dict set δ1 q2 sp S {q3 {}    {}}
    dict set δ1 q2 nl S {q1 {}    {}}
    dict set δ1 q2 w  S {q2 {}    {emit cmd [lindex $token 1]}}
    dict set δ1 q3 sp S {q3 {}    {}}
    dict set δ1 q3 nl S {q1 {}    {}}
    dict set δ1 q3 w  S {q4 {}    {emit arg [lindex $token 1]}}
    dict set δ1 q4 sp S {q5 {}    {}}
    dict set δ1 q4 nl S {q1 {}    {}}
    dict set δ1 q4 w  S {q4 {}    {emit arg [lindex $token 1]}}
    dict set δ1 q5 sp S {q5 {}    {}}
    dict set δ1 q5 nl S {q1 {}    {}}
    dict set δ1 q5 w  S {q4 {}    {emit arg [lindex $token 1]}}
    dict set δ1 q2 {} S {q6 {}    {emit success match}}
    dict set δ1 q3 {} S {q6 {}    {emit success match}}
    dict set δ1 q4 {} S {q6 {}    {emit success match}}
    dict set δ1 q5 {} S {q6 {}    {emit success match}}
    PDA create M {q0 q1 q2 q3 q4 q5 q6} {sp w nl} {S} ${δ1} q1 S {q0 q6}
} -body {
    M run {}
    lappend res [M output]
    M reset
    M run {sp sp {w foo} sp}
    lappend res [M output]
    M reset
    M run {sp {w foo} sp sp {w bar} sp}
    lappend res [M output]
} -cleanup {
    M destroy
    unset δ1
    log::lvSuppressLE i 1
} -result {{success {no input}} {cmd foo success match} {cmd foo arg bar success match}}


test pda-2.1 {} -setup {
    set res {}
    # q0    script empty
    # q1    start state, before script
    # q7    script finished
    #
    # q2    before command
    # q4    in command word
    # q5    interword space
    # q6    in argument word
    dict set δ1 q1 {} S {q0 {}    {emit success "no input"}}
    dict set δ1 q1 sp S {q2 {}    {}}
    dict set δ1 q1 nl S {q2 {}    {}}
    dict set δ1 q1 w  S {q4 {}    {newCommand [lindex $token 1]}}
    dict set δ1 q1 lb S {q2 {C}   {pushCommand}}
    dict set δ1 q1 sp C {q2 {C}   {}}
    dict set δ1 q1 nl C {q2 {C}   {}}
    dict set δ1 q1 w  C {q4 {C}   {newCommand [lindex $token 1]}}
    dict set δ1 q1 lb C {q2 {C C} {pushCommand}}
    dict set δ1 q1 rb C {q2 {}    {popCommand}}
    dict set δ1 q2 sp S {q2 {}    {}}
    dict set δ1 q2 nl S {q2 {}    {}}
    dict set δ1 q2 w  S {q4 {}    {newCommand [lindex $token 1]}}
    dict set δ1 q2 lb S {q2 {C}   {pushCommand}}
    dict set δ1 q2 sp C {q2 {C}   {}}
    dict set δ1 q2 nl C {q2 {C}   {}}
    dict set δ1 q2 w  C {q4 {C}   {newCommand [lindex $token 1]}}
    dict set δ1 q2 lb C {q2 {C C} {pushCommand}}
    dict set δ1 q2 rb C {q4 {}    {popCommand}}
    dict set δ1 q2 sp A {q2 {A}   {}}
    dict set δ1 q2 nl A {q2 {A}   {}}
    dict set δ1 q2 w  A {q4 {A}   {newCommand [lindex $token 1]}}
    dict set δ1 q2 lb A {q2 {A A} {pushCommand}}
    dict set δ1 q2 rb A {q4 {}    {popCommand}}
    dict set δ1 q4 sp S {q5 {}    {}}
    dict set δ1 q4 nl S {q2 {}    {}}
    dict set δ1 q4 w  S {q4 {}    {newCommand [lindex $token 1]}}
    dict set δ1 q4 lb S {q2 {C}   {pushCommand}}
    dict set δ1 q4 sp C {q5 {C}   {}}
    dict set δ1 q4 nl C {q2 {C}   {}}
    dict set δ1 q4 w  C {q4 {C}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q4 lb C {q2 {C C} {pushCommand}}
    dict set δ1 q4 rb C {q4 {}    {popCommand}}
    dict set δ1 q4 sp A {q5 {A}   {}}
    dict set δ1 q4 nl A {q2 {A}   {}}
    dict set δ1 q4 w  A {q4 {A}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q4 lb A {q2 {A A} {pushCommand}}
    dict set δ1 q4 rb A {q4 {}    {popCommand}}
    dict set δ1 q5 sp S {q5 {}    {}}
    dict set δ1 q5 nl S {q2 {}    {}}
    dict set δ1 q5 w  S {q6 {}    {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q5 lb S {q2 {A}   {pushCommand}}
    dict set δ1 q5 sp C {q5 {C}   {}}
    dict set δ1 q5 nl C {q2 {C}   {}}
    dict set δ1 q5 w  C {q6 {C}   {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q5 lb C {q2 {A C} {pushCommand}}
    dict set δ1 q5 rb C {q5 {}    {popCommand}}
    dict set δ1 q5 sp A {q5 {A}   {}}
    dict set δ1 q5 nl A {q2 {A}   {}}
    dict set δ1 q5 w  A {q6 {A}   {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q5 lb A {q2 {A A} {pushCommand}}
    dict set δ1 q5 rb A {q5 {}    {popCommand}}
    dict set δ1 q6 sp S {q5 {}    {}}
    dict set δ1 q6 nl S {q2 {}    {}}
    dict set δ1 q6 w  S {q6 {}    {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q6 lb S {q2 {A}   {pushCommand}}
    dict set δ1 q6 sp C {q5 {C}   {}}
    dict set δ1 q6 nl C {q2 {C}   {}}
    dict set δ1 q6 w  C {q6 {C}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q6 lb C {q2 {A C} {pushCommand}}
    dict set δ1 q6 rb C {q6 {}    {popCommand}}
    dict set δ1 q6 sp A {q5 {A}   {}}
    dict set δ1 q6 nl A {q2 {A}   {}}
    dict set δ1 q6 w  A {q6 {A}   {newCommand [lindex $token 1]}}
    dict set δ1 q6 lb A {q2 {A A} {pushCommand}}
    dict set δ1 q6 rb A {q6 {}    {popCommand}}
    dict set δ1 q2 {} S {q7 {}    {lmap command $commands {$command dump}}}
    dict set δ1 q4 {} S {q7 {}    {lmap command $commands {$command dump}}}
    dict set δ1 q5 {} S {q7 {}    {lmap command $commands {$command dump}}}
    dict set δ1 q6 {} S {q7 {}    {lmap command $commands {$command dump}}}
    PDA create M {q0 q1 q2 q4 q5 q6 q7} {sp w nl lb rb} {S C A} ${δ1} q1 S {q0 q7} {
        oo::class create Command {
            variable id words current
            constructor args {
                lassign $args id word
                lappend words $word
                set current 0
            }
            method append str {
                lset words $current [append [lindex $words $current] $str]
            }
            method nextWord {{str {}}} {
                lappend words $str
                incr current
            }
            method dump {} {
                linsert $words 0 $id:
            }
        }
        proc newCommand {{str {}}} {
            global currentCommand commands
            set currentCommand [llength $commands]
            lappend commands [list [Command new $currentCommand]]
            [lindex $commands $currentCommand] append $str
            return NC\($str)
        }
        proc currentCommand {} {
            global currentCommand commands
            lindex $commands $currentCommand
        }
        proc pushCommand {{str {}}} {
            global commandIndexStack currentCommand
            lappend commandIndexStack $currentCommand
            return
        }
        proc popCommand {} {
            global commandIndexStack currentCommand commands
            set oldCommand $currentCommand
            set currentCommand [lindex $commandIndexStack end]
            set commandIndexStack [lrange $commandIndexStack 0 end-1]
            [lindex $commands $currentCommand] nextWord #$oldCommand#
        }
        set commands {}
        set commandIndexStack {}
        # a fake outer command to return to
        newCommand {}
    }
} -body {
    M run {lb {w foo} rb}
    lappend res [M dump]
    M reset
    M run {lb {w foo} rb rb}
    lappend res [M dump]
    M reset
    M run {lb {w foo} sp {w ab} sp {w cd} nl rb nl}
    lappend res [M dump]
    M reset
    M run {{w foo} sp lb {w ab} sp {w cd} nl rb sp {w ef} nl}
    lappend res [M dump]
    M reset
    set res
} -cleanup {
    M destroy
    unset δ1
    log::lvSuppressLE i 1
} -result {{{q1 lb S -> q2 C {} {C S}} {q2 w C -> q4 C NC(foo) {C S}} {q4 rb C -> q4 {} 1 S} {q4 {} S -> q7 {} {{0: {} #1#} {1: foo}} S} 1} {{q1 lb S -> q2 C {} {C S}} {q2 w C -> q4 C NC(foo) {C S}} {q4 rb C -> q4 {} 1 S} {Error: Illegal transition (q4,rb,S)} 0} {{q1 lb S -> q2 C {} {C S}} {q2 w C -> q4 C NC(foo) {C S}} {q4 sp C -> q5 C {} {C S}} {q5 w C -> q6 C 1 {C S}} {q6 sp C -> q5 C {} {C S}} {q5 w C -> q6 C 2 {C S}} {q6 nl C -> q2 C {} {C S}} {q2 rb C -> q4 {} 1 S} {q4 nl S -> q2 {} {} S} {q2 {} S -> q7 {} {{0: {} #1#} {1: foo ab cd}} S} 1} {{q1 w S -> q4 {} NC(foo) S} {q4 sp S -> q5 {} {} S} {q5 lb S -> q2 A {} {A S}} {q2 w A -> q4 A NC(ab) {A S}} {q4 sp A -> q5 A {} {A S}} {q5 w A -> q6 A 1 {A S}} {q6 nl A -> q2 A {} {A S}} {q2 rb A -> q4 {} 1 S} {q4 sp S -> q5 {} {} S} {q5 w S -> q6 {} 2 S} {q6 nl S -> q2 {} {} S} {q2 {} S -> q7 {} {{0: {}} {1: foo #2# ef} {2: ab cd}} S} 1}}


test pda-2.2 {} -constraints {TODO} -setup {
    set res {}
    # qe    script empty
    # qf    script finished
    # q0    start state, before script
    #
    # q1    before command
    # q2    in word, more text may follow
    # q3    in word, no more text
    # q4    interword space or after command
    dict set δ1 q0 {} S {qe {}    {emit success "no input"}}

    dict set δ1 q0 sp S {q1 {}    {}}
    dict set δ1 q0 nl S {q1 {}    {}}
    dict set δ1 q0 w  S {q2 {}    {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q0 lb S {q1 {B}   {pushCommand}}
    dict set δ1 q0 dq S {q1 {Q}   {pushCommand}}
    dict set δ1 q0 lc S {q1 {C}   {pushCommand}}

    dict set δ1 q1 sp S {q1 {}    {}}
    dict set δ1 q1 nl S {q1 {}    {newCommand}}
    dict set δ1 q1 w  S {q2 {}    {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q1 lb S {q1 {B}   {pushCommand}}
    dict set δ1 q1 dq S {q1 {Q}   {pushCommand}}
    dict set δ1 q1 lc S {q1 {C}   {pushCommand}}
    
    dict set δ1 q1 sp B {q1 {B}   {}}
    dict set δ1 q1 nl B {q1 {B}   {newCommand}}
    dict set δ1 q1 w  B {q2 {B}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q1 lb B {q1 {B B} {pushCommand}}
    dict set δ1 q1 dq B {q1 {Q B} {pushCommand}}
    dict set δ1 q1 lc B {q1 {C B} {pushCommand}}
    dict set δ1 q1 rb B {q2 {}    {popCommand}}
    
    dict set δ1 q1 sp Q {q1 {Q}   {}}
    dict set δ1 q1 nl Q {q1 {Q}   {newCommand}}
    dict set δ1 q1 w  Q {q2 {Q}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q1 lb Q {q1 {B Q} {pushCommand}}
    dict set δ1 q1 dq Q {q3 {}    {popCommand}}
    dict set δ1 q1 lc Q {q1 {C Q} {pushCommand}}
    
    dict set δ1 q1 sp C {q1 {C}   {}}
    dict set δ1 q1 nl C {q1 {C}   {newCommand}}
    dict set δ1 q1 w  C {q2 {C}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q1 lb C {q1 {B C} {pushCommand}}
    dict set δ1 q1 dq C {q1 {Q C} {pushCommand}}
    dict set δ1 q1 lc C {q1 {C C} {pushCommand}}
    dict set δ1 q1 rc C {q3 {}    {popCommand}}
    
    dict set δ1 q2 sp S {q4 {}    {}}
    dict set δ1 q2 nl S {q1 {}    {newCommand}}
    dict set δ1 q2 w  S {q2 {}    {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q2 lb S {q1 {B}   {pushCommand}}
    dict set δ1 q2 dq S {q1 {Q}   {pushCommand}}
    dict set δ1 q2 lc S {q1 {C}   {pushCommand}}
    
    dict set δ1 q2 sp B {q4 {B}   {}}
    dict set δ1 q2 nl B {q1 {B}   {newCommand}}
    dict set δ1 q2 w  B {q2 {B}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q2 lb B {q1 {B B} {pushCommand}}
    dict set δ1 q2 dq B {q1 {Q B} {pushCommand}}
    dict set δ1 q2 lc B {q1 {C B} {pushCommand}}
    dict set δ1 q2 rb B {q2 {}    {popCommand}}
    
    dict set δ1 q2 sp Q {q4 {Q}   {}}
    dict set δ1 q2 nl Q {q1 {Q}   {newCommand}}
    dict set δ1 q2 w  Q {q2 {Q}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q2 lb Q {q1 {B Q} {pushCommand}}
    dict set δ1 q2 dq Q {q3 {}    {popCommand}}
    dict set δ1 q2 lc Q {q1 {C Q} {pushCommand}}
    
    dict set δ1 q2 sp C {q4 {C}   {}}
    dict set δ1 q2 nl C {q1 {C}   {newCommand}}
    dict set δ1 q2 w  C {q2 {C}   {[currentCommand] append [lindex $token 1]}}
    dict set δ1 q2 lb C {q1 {B C} {pushCommand}}
    dict set δ1 q2 dq C {q1 {Q C} {pushCommand}}
    dict set δ1 q2 lc C {q1 {C C} {pushCommand}}
    dict set δ1 q2 rc C {q3 {}    {popCommand}}
    
    dict set δ1 q3 sp S {q4 {}    {}}
    dict set δ1 q3 nl S {q1 {}    {newCommand}}
    dict set δ1 q3 sp B {q4 {B}   {}}
    dict set δ1 q3 nl B {q1 {B}   {newCommand}}
    dict set δ1 q3 rb B {q2 {}    {popCommand}}
    dict set δ1 q3 sp Q {q4 {Q}   {}}
    dict set δ1 q3 nl Q {q1 {Q}   {newCommand}}
    dict set δ1 q3 sp C {q4 {C}   {}}
    dict set δ1 q3 nl C {q1 {C}   {newCommand}}
    dict set δ1 q3 rc C {q3 {}    {popCommand}}

    dict set δ1 q4 sp S {q4 {}    {}}
    dict set δ1 q4 nl S {q1 {}    {newCommand}}
    dict set δ1 q4 w  S {q2 {}    {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q4 em S {q3 {}    {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q4 lb S {q1 {B}   {pushCommand}}
    dict set δ1 q4 dq S {q1 {Q}   {pushCommand}}
    dict set δ1 q4 lc S {q1 {C}   {pushCommand}}

    dict set δ1 q4 sp B {q4 {B}   {}}
    dict set δ1 q4 nl B {q1 {B}   {newCommand}}
    dict set δ1 q4 w  B {q2 {B}   {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q4 em B {q3 {B}   {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q4 lb B {q1 {B B} {pushCommand}}
    dict set δ1 q4 dq B {q1 {Q B} {pushCommand}}
    dict set δ1 q4 lc B {q1 {C B} {pushCommand}}
    dict set δ1 q4 rb B {q2 {}    {popCommand}}

    dict set δ1 q4 sp Q {q4 {Q}   {}}
    dict set δ1 q4 nl Q {q1 {Q}   {newCommand}}
    dict set δ1 q4 w  Q {q2 {Q}   {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q4 em Q {q3 {Q}   {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q4 lb Q {q1 {B Q} {pushCommand}}
    dict set δ1 q4 dq Q {q3 {}    {popCommand}}
    dict set δ1 q4 lc Q {q1 {C Q} {pushCommand}}

    dict set δ1 q4 sp C {q4 {C}   {}}
    dict set δ1 q4 nl C {q1 {C}   {newCommand}}
    dict set δ1 q4 w  C {q2 {C}   {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q4 em C {q3 {C}   {[currentCommand] nextWord [lindex $token 1]}}
    dict set δ1 q4 lb C {q1 {B C} {pushCommand}}
    dict set δ1 q4 dq C {q1 {Q C} {pushCommand}}
    dict set δ1 q4 lc C {q1 {C C} {pushCommand}}
    dict set δ1 q4 rc C {q3 {}    {popCommand}}

    dict set δ1 q1 {} S {qf {}    {lmap command $commands {$command dump}}}
    dict set δ1 q2 {} S {qf {}    {lmap command $commands {$command dump}}}
    dict set δ1 q3 {} S {qf {}    {lmap command $commands {$command dump}}}
    dict set δ1 q4 {} S {qf {}    {lmap command $commands {$command dump}}}
    PDA create M {qe qf q0 q1 q2 q3 q4} {sp w nl lb rb dq lc rc em} {S B Q C} ${δ1} q0 S {qe qf} {
        oo::class create Command {
            variable id words current
            constructor args {
                lassign $args id word
                lappend words $word
                set current 0
            }
            method append str {
                lset words end [lindex $words end]$str
                return AP\($str)
            }
            method nextWord {{str {}}} {
                lappend words $str
                incr current
                return NW\($str)
            }
            method dump {} {
                linsert $words 0 $id:
            }
        }
        proc newCommand {{str {}}} {
            global currentCommand commands
            set currentCommand [llength $commands]
            lappend commands [list [Command new $currentCommand]]
            [lindex $commands $currentCommand] append $str
            return NC\($str)
        }
        proc currentCommand {} {
            global currentCommand commands
            lindex $commands $currentCommand
        }
        proc pushCommand {{str {}}} {
            global commandIndexStack currentCommand
            lappend commandIndexStack $currentCommand
            return PuC\([newCommand]-[lindex $commandIndexStack end])
        }
        proc popCommand {} {
            global commandIndexStack currentCommand commands
            set oldCommand $currentCommand
            set currentCommand [lindex $commandIndexStack end]
            set commandIndexStack [lrange $commandIndexStack 0 end-1]
            [lindex $commands $currentCommand] nextWord #$oldCommand#
        }
        set commands {}
        set commandIndexStack {}
        # a fake outer command to return to
        newCommand {}
    }
} -body {
    set lex {
    {(\\.|[\w:$!%&'()*,-./?@+<=>^`|~])+}    w
    {[ \t]+}                                sp
    {\n}                                    nl
    {\;}                                    sc
    {\#}                                    ns
    {\"\"|\{\}|\[\]}                        em
    {\"}                                    dq
    {\{\*\}}                                ex
    {\{}                                    lc
    {\}}                                    rc
    {\[}                                    lb
    {\]}                                    rb
    .                                       Other
    }
    set code {set fp [open "D:\\RWTH\\Mini thesis\\EclipseTCL\\TCL trial\\excelv1.csv" r]
set secondColumnData {}
while {[gets $fp line]>=0} {
    if {[llength $line]>0} {
        lappend secondColumnData [lindex [split $line ","] 1]
    }
}
close $fp 
puts $secondColumnData}


if no {
set code {set fp [open foo r]}
}

    set tokens [::string::token text $lex $code]
    M run [lmap token $tokens {lassign $token sym beg end ; list $sym [string range $code $beg $end]}]
    lappend res [M dump]
    M reset
    set res
} -cleanup {
    M destroy
    unset δ1
    log::lvSuppressLE i 1
} -result {}


test pda-2.2 {} -setup {
    set res {}
    # qe    script empty
    # qf    script finished
    # q0    start state, before script
    #
    # q1    before command
    # q2    in word, more text may follow
    # q3    in word, no more text
    # q4    interword space or after command
    dict set δ1 q0 {} S {qe {}    {emit success "no input"}}

    dict set δ1 q0 sp S {q1 {}    {}}
    dict set δ1 q0 nl S {q1 {}    {}}
    dict set δ1 q0 w  S {q2 {}    {emit add [lindex $token 1]}}
    dict set δ1 q0 lb S {q1 {B}   {emit push B}}
    dict set δ1 q0 dq S {q1 {Q}   {emit push Q}}
    dict set δ1 q0 lc S {q1 {C}   {emit push C}}

    dict set δ1 q1 sp S {q1 {}    {}}
    dict set δ1 q1 nl S {q1 {}    {emit command}}
    dict set δ1 q1 w  S {q2 {}    {emit add [lindex $token 1]}}
    dict set δ1 q1 lb S {q1 {B}   {emit push B}}
    dict set δ1 q1 dq S {q1 {Q}   {emit push Q}}
    dict set δ1 q1 lc S {q1 {C}   {emit push C}}
    
    dict set δ1 q1 sp B {q1 {B}   {}}
    dict set δ1 q1 nl B {q1 {B}   {emit command}}
    dict set δ1 q1 w  B {q2 {B}   {emit add [lindex $token 1]}}
    dict set δ1 q1 lb B {q1 {B B} {emit push B}}
    dict set δ1 q1 dq B {q1 {Q B} {emit push Q}}
    dict set δ1 q1 lc B {q1 {C B} {emit push C}}
    dict set δ1 q1 rb B {q2 {}    {emit pop}}
    
    dict set δ1 q1 sp Q {q1 {Q}   {}}
    dict set δ1 q1 nl Q {q1 {Q}   {emit command}}
    dict set δ1 q1 w  Q {q2 {Q}   {emit add [lindex $token 1]}}
    dict set δ1 q1 lb Q {q1 {B Q} {emit push B}}
    dict set δ1 q1 dq Q {q3 {}    {emit pop}}
    dict set δ1 q1 lc Q {q1 {C Q} {emit push C}}
    
    dict set δ1 q1 sp C {q1 {C}   {}}
    dict set δ1 q1 nl C {q1 {C}   {emit command}}
    dict set δ1 q1 w  C {q2 {C}   {emit add [lindex $token 1]}}
    dict set δ1 q1 lb C {q1 {B C} {emit push B}}
    dict set δ1 q1 dq C {q1 {Q C} {emit push Q}}
    dict set δ1 q1 lc C {q1 {C C} {emit push C}}
    dict set δ1 q1 rc C {q3 {}    {emit pop}}
    
    dict set δ1 q2 sp S {q4 {}    {emit space {}}}
    dict set δ1 q2 nl S {q1 {}    {emit command}}
    dict set δ1 q2 w  S {q2 {}    {emit add [lindex $token 1]}}
    dict set δ1 q2 lb S {q1 {B}   {emit push B}}
    dict set δ1 q2 dq S {q1 {Q}   {emit push Q}}
    dict set δ1 q2 lc S {q1 {C}   {emit push C}}
    
    dict set δ1 q2 sp B {q4 {B}   {emit space {}}}
    dict set δ1 q2 nl B {q1 {B}   {emit command}}
    dict set δ1 q2 w  B {q2 {B}   {emit add [lindex $token 1]}}
    dict set δ1 q2 lb B {q1 {B B} {emit push B}}
    dict set δ1 q2 dq B {q1 {Q B} {emit push Q}}
    dict set δ1 q2 lc B {q1 {C B} {emit push C}}
    dict set δ1 q2 rb B {q2 {}    {emit pop}}
    
    dict set δ1 q2 sp Q {q4 {Q}   {emit space {}}}
    dict set δ1 q2 nl Q {q1 {Q}   {emit command}}
    dict set δ1 q2 w  Q {q2 {Q}   {emit add [lindex $token 1]}}
    dict set δ1 q2 lb Q {q1 {B Q} {emit push B}}
    dict set δ1 q2 dq Q {q3 {}    {emit pop}}
    dict set δ1 q2 lc Q {q1 {C Q} {emit push C}}
    
    dict set δ1 q2 sp C {q4 {C}   {emit space {}}}
    dict set δ1 q2 nl C {q1 {C}   {emit command}}
    dict set δ1 q2 w  C {q2 {C}   {emit add [lindex $token 1]}}
    dict set δ1 q2 lb C {q1 {B C} {emit push B}}
    dict set δ1 q2 dq C {q1 {Q C} {emit push Q}}
    dict set δ1 q2 lc C {q1 {C C} {emit push C}}
    dict set δ1 q2 rc C {q3 {}    {emit pop}}
    
    dict set δ1 q3 sp S {q4 {}    {emit space {}}}
    dict set δ1 q3 nl S {q1 {}    {emit command}}
    dict set δ1 q3 sp B {q4 {B}   {emit space {}}}
    dict set δ1 q3 nl B {q1 {B}   {emit command}}
    dict set δ1 q3 rb B {q2 {}    {emit pop}}
    dict set δ1 q3 sp Q {q4 {Q}   {emit space {}}}
    dict set δ1 q3 nl Q {q1 {Q}   {emit command}}
    dict set δ1 q3 sp C {q4 {C}   {emit space {}}}
    dict set δ1 q3 nl C {q1 {C}   {emit command}}
    dict set δ1 q3 rc C {q3 {}    {emit pop}}

    dict set δ1 q4 sp S {q4 {}    {emit space {}}}
    dict set δ1 q4 nl S {q1 {}    {emit command}}
    dict set δ1 q4 w  S {q2 {}    {emit space [lindex $token 1]}}
    dict set δ1 q4 em S {q3 {}    {emit space [lindex $token 1]}}
    dict set δ1 q4 lb S {q1 {B}   {emit push B}}
    dict set δ1 q4 dq S {q1 {Q}   {emit push Q}}
    dict set δ1 q4 lc S {q1 {C}   {emit push C}}

    dict set δ1 q4 sp B {q4 {B}   {emit space {}}}
    dict set δ1 q4 nl B {q1 {B}   {emit command}}
    dict set δ1 q4 w  B {q2 {B}   {emit space [lindex $token 1]}}
    dict set δ1 q4 em B {q3 {B}   {emit space [lindex $token 1]}}
    dict set δ1 q4 lb B {q1 {B B} {emit push B}}
    dict set δ1 q4 dq B {q1 {Q B} {emit push Q}}
    dict set δ1 q4 lc B {q1 {C B} {emit push C}}
    dict set δ1 q4 rb B {q2 {}    {emit pop}}

    dict set δ1 q4 sp Q {q4 {Q}   {emit space {}}}
    dict set δ1 q4 nl Q {q1 {Q}   {emit command}}
    dict set δ1 q4 w  Q {q2 {Q}   {emit space [lindex $token 1]}}
    dict set δ1 q4 em Q {q3 {Q}   {emit space [lindex $token 1]}}
    dict set δ1 q4 lb Q {q1 {B Q} {emit push B}}
    dict set δ1 q4 dq Q {q3 {}    {emit pop}}
    dict set δ1 q4 lc Q {q1 {C Q} {emit push C}}

    dict set δ1 q4 sp C {q4 {C}   {emit space {}}}
    dict set δ1 q4 nl C {q1 {C}   {emit command}}
    dict set δ1 q4 w  C {q2 {C}   {emit space [lindex $token 1]}}
    dict set δ1 q4 em C {q3 {C}   {emit space [lindex $token 1]}}
    dict set δ1 q4 lb C {q1 {B C} {emit push B}}
    dict set δ1 q4 dq C {q1 {Q C} {emit push Q}}
    dict set δ1 q4 lc C {q1 {C C} {emit push C}}
    dict set δ1 q4 rc C {q3 {}    {emit pop}}

    dict set δ1 q1 {} S {qf {}    {emit success done}}
    dict set δ1 q2 {} S {qf {}    {emit success done}}
    dict set δ1 q3 {} S {qf {}    {emit success done}}
    dict set δ1 q4 {} S {qf {}    {emit success done}}
    PDA create M {qe qf q0 q1 q2 q3 q4} {sp w nl lb rb dq lc rc em} {S B Q C} ${δ1} q0 S {qe qf} {
        set cmdnum 0
        set commands($cmdnum) {}
        proc appendToCommand {} {
            global commands cmdnum token
            lset commands($cmdnum) end [lindex $commands($cmdnum) end][lindex $token 1]
        }
    }
} -body {
    set lex {
    {(\\.|[\w:$!%&'()*,-./?@+<=>^`|~])+}    w
    {[ \t]+}                                sp
    {\n}                                    nl
    {\;}                                    sc
    {\#}                                    ns
    {\"\"|\{\}|\[\]}                        em
    {\"}                                    dq
    {\{\*\}}                                ex
    {\{}                                    lc
    {\}}                                    rc
    {\[}                                    lb
    {\]}                                    rb
    .                                       Other
    }
    set code {set fp [open "D:\\RWTH\\Mini thesis\\EclipseTCL\\TCL trial\\excelv1.csv" r]
set secondColumnData {}
while {[gets $fp line]>=0} {
    if {[llength $line]>0} {
        lappend secondColumnData [lindex [split $line ","] 1]
    }
}
close $fp 
puts $secondColumnData}


if no {
set code {set fp [open foo r]}
}

    set tokens [::string::token text $lex $code]
    M run [lmap token $tokens {lassign $token sym beg end ; list $sym [string range $code $beg $end]}]
    lappend res [M dump]
    lappend res [M output]
    M reset
    set res
} -cleanup {
    M destroy
    unset δ1
    log::lvSuppressLE i 1
} -result {}


::tcltest::cleanupTests

package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint skip 0
::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require pda
package require string::token

source ~/code/tcldocs/test/snippets.tcl

dict set δ (q0,ε,S) {qe {}}
dict set δ (q0,0,S) {q0 Z}
dict set δ (q0,0,Z) {q0 {Z Z}}
dict set δ (q0,1,Z) {q1 {}}
dict set δ (q1,1,Z) {q1 {}}
dict set δ (q1,ε,S) {qf {}}

test pda-1.0 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.1 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {0 0 0 0 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.2 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {0 0 0 0 1 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 0


test pda-1.3 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
    oo::objdefine M mixin -append Dump
} -body {
    M read {0 1 1}
    M dump
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{(q0,0,S) -> q0 {Z S}} {(q0,1,Z) -> q1 S} {illegal transition (q1,1,S)}}


test pda-1.4 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
    oo::objdefine M mixin -append Log
} -body {
    M read {0 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 0 -output {error     illegal transition (q1,1,S)
}


test pda-1.5 {} -setup {
    set res {}
} -body {
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q666 Z S F {qe qf}]
} -cleanup {
    log::lvSuppressLE i 1
} -result {illegal start state "q666"} -returnCodes error


test pda-1.6 {} -setup {
    set res {}
    PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ {} s q0 Z S F {qe qf}] [PDASlave new]
    M addTransition q0      ε S {qe {}    {emit success "no input"}}
    M addTransition q0      0 S {q0 Z     {emit LVL [incr n]}}
    M addTransition q0      0 Z {q0 {Z Z} {emit LVL [incr n]}}
    M addTransition {q[01]} 1 Z {q1 {}    {emit LVL [incr n -1]}}
    M addTransition q1      ε S {qf {}    {emit success match}}
} -body {
    M read {}
    lappend res [M output]
    M read {0 1 1}
    lappend res [M output]
    M read {0 0 1 1}
    lappend res [M output]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{success {no input}} {LVL 1 LVL 0} {LVL 1 LVL 2 LVL 1 LVL 0 success match}}


test pda-2.0 {} -setup {
    set res {}
    PDA create M {
        Q {q0 q1 q2 q3 q4 qe qf}
        Σ {sp w nl}
        Γ {S}
        s q0
        Z S
        F {qe qf}
    } [PDASlave new]
    M addTransition {q[0-4]} nl S {q0 {}    {}}
    M addTransition q0       ε  S {qe {}    {emit success "no input"}}
    M addTransition q0       sp S {q0 {}    {}}
    M addTransition {q[01]}  w  S {q1 {}    {emit cmd $2}}
    M addTransition {q[12]}  sp S {q2 {}    {}}
    M addTransition {q[234]} w  S {q3 {}    {emit arg $2}}
    M addTransition {q[34]}  sp S {q4 {}    {}}
    M addTransition {q[1-4]} ε  S {qf {}    {emit success match}}
} -body {
    M read {}
    lappend res [M output]
    M read {sp sp {w foo} sp}
    lappend res [M output]
    M read {sp {w foo} sp sp {w bar} sp}
    lappend res [M output]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{success {no input}} {cmd foo success match} {cmd foo arg bar success match}}


test pda-2.1 {} -setup {
    set res {}
    PDA create M {
        Q {q0 q1 q2 q3 q4 qe qf}
        Σ {sp w n}
        Γ {S}
        s q0
        Z S
        F {qe qf}
    } [PDASlave new]
    oo::objdefine M mixin -append Dump
} -body {
    M addTransition {q[0-4]} nl S {q0 {}    {}}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {Error: addTransition: no matching keys for "nl"} -returnCodes error


test pda-2.2 {} -constraints {} -setup {
    set res {}
    PDA create M {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {sp w nl lb rb dq lc rc em}
        Γ {S B Q C}
        s q0
        Z S
        F {qe qf}
    } [PDASlave new]
    set script {
        emit init
        emit enter S
    }
    # qe    script empty
    # qf    script finished
    # q0    start state, before script
    #
    # q1    before command
    # q2    in word, more text may follow
    # q3    in word, no more text
    # q4    interword space or after command
    # 20180515 expands from 25 calls to 103 rules
    M addTransition q0       ε  S {qe {}    {emit success "no input"}}
    M addTransition {q[1-4]} ε  S {qf {}    {emit success done}}

    M addTransition q0       w  S {q2 -     {emit add $2}}
    M addTransition {q[12]}  w  * {q2 -     {emit add $2}}
    M addTransition q4       w  * {q2 -     {emit space add $2}}

    M addTransition q4       em * {q3 -     {emit space add $2}}

    M addTransition q0       nl S {q1 {}}
    M addTransition {q[1-4]} nl * {q1 -     {emit command}}

    M addTransition q1       sp * {q1 -}
    M addTransition {q[01]}  sp S {q1 {}}
    M addTransition {q[2-4]} sp * {q4 -}

    M addTransition {q[0-2]} lb S {q1 {B}   {emit enter B}}
    M addTransition {q[0-2]} dq S {q1 {Q}   {emit enter Q}}
    M addTransition {q[0-2]} lc S {q1 {C}   {emit enter C}}
    
    M addTransition {q[4]}   lb S {q1 {B}   {emit space enter B}}
    M addTransition {q[4]}   dq S {q1 {Q}   {emit space enter Q}}
    M addTransition {q[4]}   lc S {q1 {C}   {emit space enter C}}
    
    M addTransition {q[12]}  lb B {q1 {B B} {emit enter B}}
    M addTransition {q[12]}  dq B {q1 {Q B} {emit enter Q}}
    M addTransition {q[12]}  lc B {q1 {C B} {emit enter C}}

    M addTransition {q[4]}   lb B {q1 {B B} {emit space enter B}}
    M addTransition {q[4]}   dq B {q1 {Q B} {emit space enter Q}}
    M addTransition {q[4]}   lc B {q1 {C B} {emit space enter C}}

    M addTransition {q[12]}  lb Q {q1 {B Q} {emit enter B}}
    M addTransition {q[12]}  lc Q {q1 {C Q} {emit enter C}}
    
    M addTransition {q[4]}   lb Q {q1 {B Q} {emit space enter B}}
    M addTransition {q[4]}   lc Q {q1 {C Q} {emit space enter C}}
    
    M addTransition {q[12]}  lb C {q1 {B C} {emit enter B}}
    M addTransition {q[12]}  dq C {q1 {Q C} {emit enter Q}}
    M addTransition {q[12]}  lc C {q1 {C C} {emit enter C}}

    M addTransition {q[4]}   lb C {q1 {B C} {emit space enter B}}
    M addTransition {q[4]}   dq C {q1 {Q C} {emit space enter Q}}
    M addTransition {q[4]}   lc C {q1 {C C} {emit space enter C}}

    M addTransition {q[1-4]} rb B {q2 {}    {emit leave}}
    
    M addTransition {q[124]} dq Q {q3 {}    {emit leave}}

    M addTransition {q[1-4]} rc C {q3 {}    {emit leave}}
    
} -body {
    set lex {
    {(\\.|[\w:$!%&'()*,-./?@+<=>^`|~])+}    w
    {[ \t]+}                                sp
    {\n}                                    nl
    {\;}                                    sc
    {\#}                                    ns
    {\"\"|\{\}|\[\]}                        em
    {\"}                                    dq
    {\{\*\}}                                ex
    {\{}                                    lc
    {\}}                                    rc
    {\[}                                    lb
    {\]}                                    rb
    .                                       Other
    }
    set code [lindex $snippets 0]
    set tokens [::string::token text $lex $code]
    M read [lmap token $tokens {lassign $token sym beg end ; list $sym [string range $code $beg $end]}] $script
    lappend res [M output]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{init enter S add set space add fp space enter B add open space enter Q add {D:\\RWTH\\Mini} space add {thesis\\EclipseTCL\\TCL} space add {trial\\excelv1.csv} leave space add r leave command add set space add secondColumnData space add {{}} command add while space enter C enter B add gets space add {$fp} space add line leave add >=0 leave space enter C command add if space enter C enter B add llength space add {$line} leave add >0 leave space enter C command add lappend space add secondColumnData space enter B add lindex space enter B add split space add {$line} space enter Q add , leave leave space add 1 leave command leave command leave command add close space add {$fp} command add puts space add {$secondColumnData} success done}}

package require sqlite3

sqlite3 ::dbcmd :memory:

source ../../tcldocs/topdir/lib/td/dbinit.tcl
source ../../tcldocs/topdir/lib/td/db.tcl

test pda-2.3 {} -constraints {} -setup {
    set res {}
    set slave [PDASlave new {
        proc GetRowIds {type args} {
            if no {
            emit [info level 0]
            }
            concat {*}[lmap name $args {
                dbGetRowIDs2 $type $name
            }]
        }
        proc parseExpressions strs {
            if no {
            emit [info level 0]
            }
            global data
            set explex {}
            foreach op [lsort -decreasing [dbcmd eval {select name from t0 where type in ('function', 'operator')}]] {
                if {![string is alpha -strict $op]} {
                    lappend explex [string map {| \\| ^ \\^ * \\* + \\+ ? \\?} $op] $op
                } else {
                    lappend explex \\y(?:$op)\\y $op
                }
            }
            # Added to avoid false positives with alpha operators matching partial
            # words.
            lappend explex {\w+} w
            # Added to make sure the tokenizer doesn't choke.
            lappend explex . _
            foreach str $strs {
                foreach tok [tokenize $explex $str] {
                    set label [lindex $tok 0]
                    if {$label in {w _}} {
                        continue
                    } else {
                        foreach type {operator function} {
                            foreach id [GetRowIds $type $label] {
                                dict incr data $id
                            }
                        }
                    }
                }
            }
        }
        proc action {what {str {}}} {
            global data word commands contexts cmdnum ctxnum cmddict ctxdict
            switch $what {
                init {
                    set word {}
                    set commands {}
                    set cmdnum 0
                    set cmddict {}
                    set contexts {}
                    set ctxnum 0
                    set ctxdict {}
                }
                bctx {
                    incr ctxnum
                    dict set ctxdict $ctxnum [list $str]
                    set contexts [linsert $contexts 0 $ctxnum]
                    action bcmd
                }
                ectx {
                    action ecmd
                    set contexts [lassign $contexts idx]
                    set word <$idx>
                }
                bcmd {
                    incr cmdnum
                    set commands [linsert $commands 0 $cmdnum]
                    action bwrd
                }
                ecmd {
                    action ewrd
                    set commands [lassign $commands idx]
                    dict lappend ctxdict [lindex $contexts 0] ($idx)
                }
                bwrd {
                    set word {}
                }
                awrd {
                    append word $str
                }
                ewrd {
                    if no {
                    emit word $word
                    }
                    set cmdidx [lindex $commands 0]
                    dict lappend cmddict $cmdidx $word
                    set cmdwix [expr {[llength [dict get $cmddict $cmdidx]] - 1}]
                    set cmdtype [lindex [dict get $cmddict $cmdidx] 0]
                    if {$cmdwix eq 0} {
                        dict lappend ::output commands $word
                    }
                    switch $cmdtype {
                        if - while {
                            if {$cmdwix eq 1} {
                                if no {
                                my Note [format {command %s: expression argument "%s"} $cmdtype [stringize $word]]
                                }
                                dict lappend ::output expressions [stringize $word]
                            }
                        }
                        default {
                        }
                    }
                    set ctxidx [lindex $contexts 0]
                    set ctxtype [lindex [dict get $ctxdict $ctxidx] 0]
                    if no {
                    emit [format {command %2d/%d in %2d%s: "%s"} $cmdidx $cmdwix $ctxidx $ctxtype $word]
                    }
                }
                succ {
                    action ectx
                    dict for {k v} $::output {
                        dict set ::output $k [lsort -unique -dictionary $v]
                    }
                    if no {
                    emit {*}$::output
                    }
                    try {
                        parseExpressions [dict get $::output expressions]
                        set ids [GetRowIds command {*}[dict get $::output commands]]
                        foreach id $ids {
                            dict incr data $id
                        }
                    } on error msg {
                        emit $msg
                    }
                    if no {
                    emit [lsort -integer [dict keys $data]]
                    }
                    emit [join [lmap rowid [lsort -integer [dict keys $data]] {dbGet $rowid}] \n]
                }
                default {
                    ;
                }
            }
        }
        proc stringize word {
            global ctxdict cmddict
            if no {
                    cmdref { append res ($string) }
            }
            set lex {
                {<\d+>}   ctxref
                {\(\d+\)} cmdref
                {[^<(]+}  other
            }
            set res {}
            foreach token [tokenize $lex $word] {
                lassign $token type begin end
                set string [string range $word $begin $end]
                switch $type {
                    ctxref {
                        set string [string trim $string <>]
                        set ctx [dict get $ctxdict $string]
                        if {[lindex $ctx 0] eq "B"} {
                            append res C\($string)
                        } else {
                            append res C\([join [stringize [join [lrange $ctx 1 end]]]])
                        }
                    }
                    cmdref {
                        set cmd [dict get $cmddict [string trim $string ()]]
                        append res [join [stringize [join $cmd]]]
                    }
                    default {
                        append res $string
                    }
                }
            }
            return $res
        }
    }]
    $slave alias tokenize string::token text
    $slave alias dbcmd dbcmd
    $slave alias dbGetRowIDs2 dbGetRowIDs2
    $slave alias dbGet dbGet
    PDA create M {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {sp w nl lb rb dq lc rc em}
        Γ {S B Q C}
        s q0
        Z S
        F {qe qf}
    } $slave
    set script {
        action init
        action bctx S
    }
    oo::objdefine M mixin -append Dump
    # qe    script empty
    # qf    script finished
    # q0    start state, before script
    #
    # q1    before command
    # q2    in word, more text may follow
    # q3    in word, no more text
    # q4    interword space or after command
    M addTransition q0       ε  S {qe {}    {action succ "no input"}}
    M addTransition {q[1-4]} ε  S {qf {}    {action succ done}}

    M addTransition q0       w  S {q2 -     {action awrd $2}}
    M addTransition {q[12]}  w  * {q2 -     {action awrd $2}}
    M addTransition q4       w  * {q2 -     {action ewrd ; action bwrd ; action awrd $2}}

    M addTransition q4       em * {q3 -     {action ewrd ; action bwrd ; action awrd $2}}

    M addTransition q0       nl S {q1 {}}
    M addTransition {q[1-4]} nl * {q1 -     {action ecmd ; action bcmd}}

    M addTransition q1       sp * {q1 -}
    M addTransition {q[01]}  sp S {q1 {}}
    M addTransition {q[2-4]} sp * {q4 -}

    M addTransition {q[0-2]} lb S {q1 {B}   {action bctx B}}
    M addTransition {q[0-2]} dq S {q1 {Q}   {action bctx Q}}
    M addTransition {q[0-2]} lc S {q1 {C}   {action bctx C}}
    
    M addTransition {q[4]}   lb S {q1 {B}   {action ewrd ; action bwrd ; action bctx B}}
    M addTransition {q[4]}   dq S {q1 {Q}   {action ewrd ; action bwrd ; action bctx Q}}
    M addTransition {q[4]}   lc S {q1 {C}   {action ewrd ; action bwrd ; action bctx C}}
    
    M addTransition {q[12]}  lb B {q1 {B B} {action bctx B}}
    M addTransition {q[12]}  dq B {q1 {Q B} {action bctx Q}}
    M addTransition {q[12]}  lc B {q1 {C B} {action bctx C}}

    M addTransition {q[4]}   lb B {q1 {B B} {action ewrd ; action bwrd ; action bctx B}}
    M addTransition {q[4]}   dq B {q1 {Q B} {action ewrd ; action bwrd ; action bctx Q}}
    M addTransition {q[4]}   lc B {q1 {C B} {action ewrd ; action bwrd ; action bctx C}}

    M addTransition {q[12]}  lb Q {q1 {B Q} {action bctx B}}
    M addTransition {q[12]}  lc Q {q1 {C Q} {action bctx C}}
    
    M addTransition {q[4]}   lb Q {q1 {B Q} {action ewrd ; action bwrd ; action bctx B}}
    M addTransition {q[4]}   lc Q {q1 {C Q} {action ewrd ; action bwrd ; action bctx C}}
    
    M addTransition {q[12]}  lb C {q1 {B C} {action bctx B}}
    M addTransition {q[12]}  dq C {q1 {Q C} {action bctx Q}}
    M addTransition {q[12]}  lc C {q1 {C C} {action bctx C}}

    M addTransition {q[4]}   lb C {q1 {B C} {action ewrd ; action bwrd ; action bctx B}}
    M addTransition {q[4]}   dq C {q1 {Q C} {action ewrd ; action bwrd ; action bctx Q}}
    M addTransition {q[4]}   lc C {q1 {C C} {action ewrd ; action bwrd ; action bctx C}}

    M addTransition {q[1-4]} rb B {q2 {}    {action ectx}}
    
    M addTransition {q[124]} dq Q {q3 {}    {action ectx}}

    M addTransition {q[1-4]} rc C {q3 {}    {action ectx}}
    
} -body {
    set lex {
    {(\\.|[\w:$!%&'()*,-./?@+<=>^`|~])+}    w
    {[ \t]+}                                sp
    {\n}                                    nl
    {\;}                                    sc
    {\#}                                    ns
    {\"\"|\{\}|\[\]}                        em
    {\"}                                    dq
    {\{\*\}}                                ex
    {\{}                                    lc
    {\}}                                    rc
    {\[}                                    lb
    {\]}                                    rb
    .                                       Other
    }
    set code [lindex $snippets 0]
    set tokens [::string::token text $lex $code]
    M read [lmap token $tokens {lassign $token sym beg end ; list $sym [string range $code $beg $end]}] $script
    M dump
    lindex [M output] 0
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {[> (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Greater than")
[>= (operator)](http://www.tcl.tk/man/tcl/TclCmd/expr.htm "Greater than or equal")
[close](http://www.tcl.tk/man/tcl/TclCmd/close.htm "Close an open channel")
[gets](http://www.tcl.tk/man/tcl/TclCmd/gets.htm "Read a line from a channel")
[if](http://www.tcl.tk/man/tcl/TclCmd/if.htm "Execute scripts conditionally")
[lappend](http://www.tcl.tk/man/tcl/TclCmd/lappend.htm "Append list elements onto a variable")
[lindex](http://www.tcl.tk/man/tcl/TclCmd/lindex.htm "Retrieve an element from a list")
[llength](http://www.tcl.tk/man/tcl/TclCmd/llength.htm "Count the number of elements in a list")
[open](http://www.tcl.tk/man/tcl/TclCmd/open.htm "Open a file-based or command pipeline channel")
[puts](http://www.tcl.tk/man/tcl/TclCmd/puts.htm "Write to a channel")
[set](http://www.tcl.tk/man/tcl/TclCmd/set.htm "Read and write variables")
[split](http://www.tcl.tk/man/tcl/TclCmd/split.htm "Split a string into a proper Tcl list")
[while](http://www.tcl.tk/man/tcl/TclCmd/while.htm "Execute script repeatedly as long as a condition is met")}


::tcltest::cleanupTests

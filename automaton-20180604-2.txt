Variant definitions of automata[edit]

Automata are defined to study useful machines under mathematical formalism. So, the definition of an automaton is open to variations according to the "real world machine", which we want to model using the automaton. People have studied many variations of automata. The most standard variant, which is described above, is called a deterministic finite automaton. The following are some popular variations in the definition of different components of automata.

Input
Finite input: An automaton that accepts only finite sequence of symbols. The above introductory definition only encompasses finite words.
Tree word input: The input may be a tree of symbols instead of sequence of symbols. In this case after reading each symbol, the automaton reads all the successor symbols in the input tree. It is said that the automaton makes one copy of itself for each successor and each such copy starts running on one of the successor symbols from the state according to the transition relation of the automaton. Such an automaton is called a tree automaton.

States
Finite states: An automaton that contains only a finite number of states. The above introductory definition describes automata with finite numbers of states.
Stack memory: An automaton may also contain some extra memory in the form of a stack in which symbols can be pushed and popped. This kind of automaton is called a pushdown automaton

Transition function
Deterministic: For a given current state and an input symbol, if an automaton can only jump to one and only one state then it is a deterministic automaton.
Nondeterministic: An automaton that, after reading an input symbol, may jump into any of a number of states, as licensed by its transition relation. Notice that the term transition function is replaced by transition relation: The automaton non-deterministically decides to jump into one of the allowed choices. Such automata are called nondeterministic automata.
Alternation: This idea is quite similar to tree automaton, but orthogonal. The automaton may run its multiple copies on the same next read symbol. Such automata are called alternating automata. Acceptance condition must satisfy all runs of such copies to accept the input.

Acceptance condition
Acceptance of finite words: Same as described in the informal definition above.
Probabilistic acceptance: An automaton need not strictly accept or reject an input. It may accept the input with some probability between zero and one. For example, quantum finite automaton, geometric automaton and metric automaton have probabilistic acceptance.

Different combinations of the above variations produce many classes of automaton.

Automata theory is a subject matter that studies properties of various types of automata. For example, the following questions are studied about a given type of automata.

Which class of formal languages is recognizable by some type of automata? (Recognizable languages)
Are certain automata closed under union, intersection, or complementation of formal languages? (Closure properties)
How expressive is a type of automata in terms of recognizing a class of formal languages? And, their relative expressive power? (Language hierarchy)

Automata theory also studies the existence or nonexistence of any effective algorithms to solve problems similar to the following list:

Does an automaton accept any input word? (Emptiness checking)
Is it possible to transform a given non-deterministic automaton into deterministic automaton without changing the recognizable language? (Determinization)
For a given formal language, what is the smallest automaton that recognizes it? (Minimization)

Classes of automata[edit]

The following is an incomplete list of types of automata.

Recognizable language

Nondeterministic/Deterministic Finite state machine (FSM) regular languages 
Deterministic pushdown automaton (DPDA) deterministic context-free languages 
Pushdown automaton (PDA) context-free languages 
Linear bounded automaton (LBA) context-sensitive languages 
Turing machine recursively enumerable languages 

Hierarchy in terms of powers[edit]

The following is an incomplete hierarchy in terms of powers of different types of virtual machines. The hierarchy reflects the nested categories of languages the machines are able to accept.[1]

Highest Power
 
Multidimensional Turing Machine
Multitape Turing Machine (MTM)
Probabilistic Turing Machine (PTM)
Nondeterministic Turing Machine (NTM)
Deterministic Turing Machine (DTM)
Nondeterministic Push Down Automaton (NPDA-II) with 2 push-down stores
Deterministic Push Down Automaton (DPDA-II) with 2 push-down stores
Linear Bounded Automaton (LBA)
Nondeterministic Push Down Automaton (NPDA-I) with 1 push-down store
Deterministic Push Down Automaton (DPDA-I) with 1 push-down store
Deterministic Finite Automaton (DFA), Nondeterministic Finite Automaton (NFA)

Lowest Power


NFA

An NFA is represented formally by a 5-tuple, (Q, Σ, Δ, q0, F), consisting of
a finite set of states Q
a finite set of input symbols Σ
a transition function Δ : Q × Σ → P(Q).
an initial (or start) state q0 ∈ Q
a set of states F distinguished as accepting (or final) states F ⊆ Q.

Here, P(Q) denotes the power set of Q. Let w = a1a2 ... an be a word over the alphabet Σ. The automaton M accepts the word w if a sequence of states, r0,r1, ..., rn, exists in Q with the following conditions:
1.r0 = q0
2.ri+1 ∈ Δ(ri, ai+1), for i = 0, ..., n−1
3.rn ∈ F.

In words, the first condition says that the machine starts in the start state q0. The second condition says that given each character of string w, the machine will transition from state to state according to the transition function Δ. The last condition says that the machine accepts w if the last input of w causes the machine to halt in one of the accepting states. In order for w being accepted by M it is not required that every state sequence ends in an accepting state, it is sufficient if one does. Otherwise, i.e. if it is impossible at all to get from q0 to a state from F by following w, it is said that the automaton rejects the string. The set of strings M accepts is the language recognized by M and this language is denoted by L(M).

We can also define L(M) in terms of Δ*: Q × Σ* → P(Q) such that:
1.Δ*(r, ε)= {r} where ε is the empty string, and
2.If x ∈ Σ*, a ∈ Σ, and Δ*(r, x)={r1, r2,..., rk} then Δ*(r, xa)= Δ(r1, a)∪...∪Δ(rk, a).

Now L(M) = {w | Δ*(q0, w) ∩ F ≠ ∅}.

Note that there is a single initial state, which is not necessary. Sometimes, NFAs are defined with a set of initial states. There is an easy construction that translates a NFA with multiple initial states to a NFA with single initial state, which provides a convenient notation.

DFA acceptor

A deterministic finite state machine or acceptor deterministic finite state machine is a quintuple ( Σ , S , s 0   , δ , F )   {\displaystyle (\Sigma ,S,s_{0},\delta ,F)}  (\Sigma ,S,s_{0},\delta ,F), where: Σ   {\displaystyle \Sigma }  \Sigma  is the input alphabet (a finite, non-empty set of symbols).
S   {\displaystyle S}  S is a finite, non-empty set of states.
s 0     {\displaystyle s_{0}}  s_{0} is an initial state, an element of S   {\displaystyle S}  S.
δ   {\displaystyle \delta }  \delta  is the state-transition function: δ : S × Σ → S   {\displaystyle \delta :S\times \Sigma \rightarrow S}  \delta :S\times \Sigma \rightarrow S (in a nondeterministic finite automaton it would be δ : S × Σ → P   ( S )   {\displaystyle \delta :S\times \Sigma \rightarrow {\mathcal {P}}(S)}  \delta :S\times \Sigma \rightarrow {\mathcal {P}}(S), i.e., δ   {\displaystyle \delta }  \delta  would return a set of states).
F   {\displaystyle F}  F is the set of final states, a (possibly empty) subset of S   {\displaystyle S}  S.


For both deterministic and non-deterministic FSMs, it is conventional to allow δ   {\displaystyle \delta }  \delta  to be a partial function, i.e. δ ( q , x )   {\displaystyle \delta (q,x)}  \delta (q,x) does not have to be defined for every combination of q ∈ S   {\displaystyle q\in S}  q\in S and x ∈ Σ   {\displaystyle x\in \Sigma }  x\in \Sigma . If an FSM M   {\displaystyle M}  M is in a state q   {\displaystyle q}  q, the next symbol is x   {\displaystyle x}  x and δ ( q , x )   {\displaystyle \delta (q,x)}  \delta (q,x) is not defined, then M   {\displaystyle M}  M can announce an error (i.e. reject the input). This is useful in definitions of general state machines, but less useful when transforming the machine. Some algorithms in their default form may require total functions.

A finite state machine has the same computational power as a Turing machine that is restricted such that its head may only perform "read" operations, and always has to move from left to right. That is, each formal language accepted by a finite state machine is accepted by such a kind of restricted Turing machine, and vice versa.[15]

DFA transducer

A finite-state transducer is a sextuple ( Σ , Γ , S , s 0   , δ , ω )   {\displaystyle (\Sigma ,\Gamma ,S,s_{0},\delta ,\omega )}  (\Sigma ,\Gamma ,S,s_{0},\delta ,\omega ), where: Σ   {\displaystyle \Sigma }  \Sigma  is the input alphabet (a finite non-empty set of symbols).
Γ   {\displaystyle \Gamma }  \Gamma  is the output alphabet (a finite, non-empty set of symbols).
S   {\displaystyle S}  S is a finite, non-empty set of states.
s 0     {\displaystyle s_{0}}  s_{0} is the initial state, an element of S   {\displaystyle S}  S. In a nondeterministic finite automaton, s 0     {\displaystyle s_{0}}  s_{0} is a set of initial states.
δ   {\displaystyle \delta }  \delta  is the state-transition function: δ : S × Σ → S   {\displaystyle \delta :S\times \Sigma \rightarrow S}  \delta :S\times \Sigma \rightarrow S.
ω   {\displaystyle \omega }  \omega  is the output function.


If the output function is a function of a state and input alphabet (ω : S × Σ → Γ   {\displaystyle \omega :S\times \Sigma \rightarrow \Gamma }  \omega :S\times \Sigma \rightarrow \Gamma ) that definition corresponds to the Mealy model, and can be modelled as a Mealy machine. If the output function depends only on a state (ω : S → Γ   {\displaystyle \omega :S\rightarrow \Gamma }  \omega :S\rightarrow \Gamma ) that definition corresponds to the Moore model, and can be modelled as a Moore machine. A finite-state machine with no output function at all is known as a semiautomaton or transition system.

If we disregard the first output symbol of a Moore machine, ω ( s 0   )   {\displaystyle \omega (s_{0})}  \omega (s_{0}), then it can be readily converted to an output-equivalent Mealy machine by setting the output function of every Mealy transition (i.e. labeling every edge) with the output symbol given of the destination Moore state. The converse transformation is less straightforward because a Mealy machine state may have different output labels on its incoming transitions (edges). Every such state needs to be split in multiple Moore machine states, one for every incident output symbol.[16]

(N/D)PDA

A (not necessarily deterministic) PDA M   {\displaystyle M}  M can be defined as a 7-tuple:

M = ( Q  , Σ  , Γ  , q 0    , Z 0    , A  , δ  )   {\displaystyle M=(Q\,,\Sigma \,,\Gamma \,,q_{0}\,,Z_{0}\,,A\,,\delta \,)}  M=(Q\,,\Sigma \,,\Gamma \,,q_{0}\,,Z_{0}\,,A\,,\delta \,)

where

Q    {\displaystyle Q\,}  Q\, is a finite set of states
Σ    {\displaystyle \Sigma \,}  \Sigma \, is a finite set of input symbols
Γ    {\displaystyle \Gamma \,}  \Gamma \, is a finite set of stack symbols
q 0    ∈ Q    {\displaystyle q_{0}\,\in Q\,}  q_{0}\,\in Q\, is the start state
Z 0    ∈ Γ    {\displaystyle Z_{0}\,\in \Gamma \,}  Z_{0}\,\in \Gamma \, is the starting stack symbol
A  ⊆ Q    {\displaystyle A\,\subseteq Q\,}  A\,\subseteq Q\,, where A   {\displaystyle A}  A is the set of accepting states
δ    {\displaystyle \delta \,}  \delta\, is a transition function, where
δ : ( Q  × ( Σ  ∪ { ε   }  ) × Γ  ) ⟶ P   ( Q × Γ ∗   )   {\displaystyle \delta \colon (Q\,\times (\Sigma \,\cup \left\{\varepsilon \,\right\})\times \Gamma \,)\longrightarrow {\mathcal {P}}(Q\times \Gamma ^{*})}  \delta \colon (Q\,\times (\Sigma \,\cup \left\{\varepsilon \,\right\})\times \Gamma \,)\longrightarrow {\mathcal {P}}(Q\times \Gamma ^{{*}})where ∗   {\displaystyle *}  * is the Kleene star, meaning that Γ ∗     {\displaystyle \Gamma ^{*}}  \Gamma ^{*} is "the set of all finite strings (including the empty string ε   {\displaystyle \varepsilon }  \varepsilon ) of elements of Γ   {\displaystyle \Gamma }  \Gamma ", ε   {\displaystyle \varepsilon }  \varepsilon  denotes the empty string, and P   ( X )   {\displaystyle {\mathcal {P}}(X)}  {\mathcal {P}}(X) is the power set of a set X   {\displaystyle X}  X.
M is deterministic if it satisfies both the following conditions:
For any q ∈ Q , a ∈ Σ ∪ { ε }  , x ∈ Γ   {\displaystyle q\in Q,a\in \Sigma \cup \left\{\varepsilon \right\},x\in \Gamma }  q\in Q,a\in \Sigma \cup \left\{\varepsilon \right\},x\in \Gamma , the set δ ( q , a , x )    {\displaystyle \delta (q,a,x)\,}  \delta (q,a,x)\, has at most one element.
For any q ∈ Q , x ∈ Γ   {\displaystyle q\in Q,x\in \Gamma }  q\in Q,x\in \Gamma , if δ ( q , ε , x ) ≠ ∅    {\displaystyle \delta (q,\varepsilon ,x)\not =\emptyset \,}  \delta (q,\varepsilon ,x)\not =\emptyset \,, then δ ( q , a , x  )  = ∅   {\displaystyle \delta \left(q,a,x\right)=\emptyset }  \delta \left(q,a,x\right)=\emptyset  for every a ∈ Σ .   {\displaystyle a\in \Sigma .}  a\in \Sigma .

There are two possible acceptance criteria: acceptance by empty stack and acceptance by final state. The two are not equivalent for the deterministic pushdown automaton (although they are for the non-deterministic pushdown automaton). The languages accepted by empty stack are those languages that are accepted by final state and are prefix-free: no word in the language is the prefix of another word in the language.

The usual acceptance criterion is final state, and it is this acceptance criterion which is used to define the deterministic context-free languages.

LBA

A linear bounded automaton is a nondeterministic Turing machine that satisfies the following three conditions:
Its input alphabet includes two special symbols, serving as left and right endmarkers.
Its transitions may not print other symbols over the endmarkers.
Its transitions may neither move to the left of the left endmarker nor to the right of the right endmarker.[1]:225

In other words: instead of having potentially infinite tape on which to compute, computation is restricted to the portion of the tape containing the input plus the two tape squares holding the endmarkers.

An alternative, less restrictive definition is as follows:
Like a Turing machine, an LBA possesses a tape made up of cells that can contain symbols from a finite alphabet, a head that can read from or write to one cell on the tape at a time and can be moved, and a finite number of states.
An LBA differs from a Turing machine in that while the tape is initially considered to have unbounded length, only a finite contiguous portion of the tape, whose length is a linear function of the length of the initial input, can be accessed by the read/write head; hence the name linear bounded automaton.[1]:225

This limitation makes an LBA a somewhat more accurate model of a real-world computer than a Turing machine, whose definition assumes unlimited tape.

The strong and the weaker definition lead to the same computational abilities of the respective automaton classes,[1]:225 due to the linear speedup theorem.

(N/D)TM

Following Hopcroft and Ullman (1979, p. 148), a (one-tape) Turing machine can be formally defined as a 7-tuple M = ⟨ Q , Γ , b , Σ , δ , q 0   , F ⟩   {\displaystyle M=\langle Q,\Gamma ,b,\Sigma ,\delta ,q_{0},F\rangle }  M=\langle Q,\Gamma ,b,\Sigma ,\delta ,q_{0},F\rangle  where
Q   {\displaystyle Q}  Q is a finite, non-empty set of states;
Γ   {\displaystyle \Gamma }  \Gamma  is a finite, non-empty set of tape alphabet symbols;
b ∈ Γ   {\displaystyle b\in \Gamma }  b\in \Gamma  is the blank symbol (the only symbol allowed to occur on the tape infinitely often at any step during the computation);
Σ ⊆ Γ ∖ { b }   {\displaystyle \Sigma \subseteq \Gamma \setminus \{b\}}  \Sigma \subseteq \Gamma \setminus \{b\} is the set of input symbols, that is, the set of symbols allowed to appear in the initial tape contents;
q 0   ∈ Q   {\displaystyle q_{0}\in Q}  q_{0}\in Q is the initial state;
F ⊆ Q   {\displaystyle F\subseteq Q}  F\subseteq Q is the set of final states or accepting states. The initial tape contents is said to be accepted by M   {\displaystyle M}  M if it eventually halts in a state from F   {\displaystyle F}  F.
δ : ( Q ∖ F ) × Γ → Q × Γ × { L , R }   {\displaystyle \delta :(Q\setminus F)\times \Gamma \rightarrow Q\times \Gamma \times \{L,R\}}  \delta :(Q\setminus F)\times \Gamma \rightarrow Q\times \Gamma \times \{L,R\} is a partial function called the transition function, where L is left shift, R is right shift. (A relatively uncommon variant allows "no shift", say N, as a third element of the latter set.) If δ   {\displaystyle \delta }  \delta  is not defined on the current state and the current tape symbol, then the machine halts;[21]


 Anything that operates according to these specifications is a Turing machine.

